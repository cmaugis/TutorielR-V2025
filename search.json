[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Tutoriel R",
    "section": "",
    "text": "Preface\nCe site est dédié aux tutoriels R pour la formation modIA de l’INSA Toulouse mais peuvent être bien sûr utilisés plus largement.\nCe tutoriel est composé de 4 parties :\n\nPartie 1 : présentation de R et de RStudio, gestion du répertoire de travail, des librairies, …\nPartie 2 : présentation des principaux objets en R, les premiers graphiques, la programmation, l’importation/exportation, …\nPartie 3 : présentation d’outils pour la manipulation des lois usuelles, de statistiques descriptives, …\nPartie 4 : présentation de tidyverse (en particulier de dplyr, stringr, ggplot2), les essentiels de la rédaction de documents avec Rmarkdown et quarto, Python sous Rstudio avec reticulate, …\n\nLa rédaction de ces tutoriels s’appuie principalement sur :\n\ndes supports développés avec/par des collègues de l’INSA Toulouse et de l’IMT (qu’ils en soient ici remerciés)\nles livres suivants :\n\nR for data science: import, tidy, transform, visualize, and model data de Wickham, H. and Grolemund, G. (2016)\nStatistiques avec R de Cornillon et al. (2010)\nR markdown: The definitive guide de Xie et al. (2018)\nggplot2: elegant graphics for data analysis de Wickham (2016)\n\nde plusieurs sites web qui seront mentionnés au fur et à mesure\n\nSi vous relevez des erreurs, merci de m’en informer.\n\n\n\n\nCornillon, Pierre-André, François Husson, Nicolas Jégou, Eric Matzner-Lober, Julie Josse, Arnaud Guyader, Laurent Rouviére, and Maela Kloareg. 2010. Statistiques Avec r. Rennes (Presses universitaires de).\n\n\nWickham, H. 2016. Ggplot2: Elegant Graphics for Data Analysis. springer.\n\n\nWickham, H., and G. Grolemund. 2016. R for Data Science: Import, Tidy, Transform, Visualize, and Model Data. \" O’Reilly Media, Inc.\". https://r4ds.had.co.nz/.\n\n\nXie, Y., J. J. Allaire, and G. Grolemund. 2018. R Markdown: The Definitive Guide. CRC Press."
  },
  {
    "objectID": "Part1-Intro.html#a-propos-de-r",
    "href": "Part1-Intro.html#a-propos-de-r",
    "title": "1  Démarrer avec R et découverte de RStudio",
    "section": "1.1 A propos de R ",
    "text": "1.1 A propos de R \nLe logiciel R est développé depuis les années 90 par un groupe de volontaires de différents pays et par une large communauté d’utilisateurs. C’est un logiciel libre, publié sous licence GNU GPL et multiplateforme (fonctionne sur systèmes Linux, Mac OS X ou Windows). Il est facile à installer à partir de la page du CRAN (ou d’un site miroir); le CRAN contient toutes les ressources nécessaires à l’utilisateur de R, débutant ou expérimenté : fichiers d’installation, mises à jour, librairies, FAQ, newsletter, documentation… R fait partie des logiciels les plus utilisés de la communauté statistique académique et aussi de plus en plus dans les services R&D des entreprises en concurrence avec les logiciels commerciaux.\nDans sa structure, R est un langage de programmation d’une syntaxe voisine à celle du langage C et capable de manipuler des objets complexes sous forme de matrice, scalaire, vecteur, liste, facteur et aussi data frame. Il dispose également d’une très riche librairie de quasiment toutes les procédures et méthodes statistiques de la littérature. Plus précisément, toutes les recherches récentes sont d’abord développées et diffusées à l’aide de ce logiciel par la communauté scientifique.\nPour suivre cette série de tutoriels, vous devez commencer par installer R (version &gt; 4.4.1) sur votre ordinateur. Pour cela, rendez-vous sur l’une des pages suivantes et suivez les instructions :\n\nInstallation de R sous Windows\nInstallation de R sous Mac\nInstallation pour linux"
  },
  {
    "objectID": "Part1-Intro.html#a-propos-de-rstudio",
    "href": "Part1-Intro.html#a-propos-de-rstudio",
    "title": "1  Démarrer avec R et découverte de RStudio",
    "section": "1.2 A propos de RStudio ",
    "text": "1.2 A propos de RStudio \nRStudio n’est pas qu’une interface graphique pour R, il s’agit d’un environnement de développement intégré, proposant des outils et facilite l’écriture de scripts et l’utilisation de R. La version gratuite de RStudio étant déjà très riche en fonctionnalités, elle est suffisante pour les enseignements.\n\n1.2.1 Description des fenêtres de RStudio\nUne fois R et RStudio installés sur votre machine, vous pouvez démarrer RStudio.\nAu lancement de RStudio, l’écran est découpé en trois grandes zones.\n\n\n\n\n\n\nFigure 1.1: 3 zones à l’ouverture de RStudio\n\n\n\n\nLa zone de gauche s’appelle la Console, on peut y lire au lancement la version de R que RStudio a chargé. Après le texte d’entrée, la ligne commence par &gt; qui est l’invite de commande. RStudio est prêt à recevoir votre première commande. On peut se servir de R comme d’une calculatrice. Vous pouvez par exemple taper &gt; 2+3 et taper Entrée. Le résultat apparait alors dans la console.\nEn haut à droite, on peut voir dans Environnement la liste des objets et fonctions créés au fur et à mesure du travail. On a également accès à l’historique des commandes dans History.\nEn bas à droite, on trouve plusieurs onglets :\n\nFiles : permet de voir le contenu du répertoire de travail\nPlots : permet de visualiser les graphiques créés\nPackages : liste les packages installés pour les charger, mettre à jour, en installer d’autres (voir la section dédiée)\nHelp : permet d’accéder à l’aide en ligne\n\nVous pouvez modifier la configuration des onglets de RStudio en allant dans Preferences -&gt; Pane Layout.\n\n\n1.2.2 Types de documents avec RStudio\nEn allant dans File -&gt; New File ou en cliquant sur la flèche à côté de l’icone de New File (en haut à gauche), RStudio propose de nombreux types de document. Vous pouvez noter que l’on peut utiliser RStudio également pour faire du python, du C++, … Nous allons ici ne parler que de quelques types de fichiers que l’on utilisera par la suite. Lorsque l’on sélectionne un type de fichier, une quatrième fenêtre en haut à gauche de l’interface de RStudio s’ouvre.\n\n\n\n\n\nFigure 1.2: Les types de fichiers disponibles avec RStudio\n\n\n\n\nPour créer un script R, il suffit de sélectionner R Script. Ce script peut être enregistré à tout moment dans un fichier avec l’extension ” .R” (ex. monScript.R) dans le répertoire courant en cliquant sur l’icône de disquette ou par File-&gt;Save. Vous pouvez l’ouvrir à tout moment grâce au menu File –&gt; Open file..., à l’icône dossier ou en double cliquant sur le fichier monScript.R. Il est également possible d’executer un script directement depuis la console grâce à la commande source(\"monScript.R\").\nVous pouvez créer un document (rapport, slides, …) à l’aide de RMarkdown en sélectionnant R markdown .... En particulier, vous avez la possibilité d’éditer directement des documents au format pdf ou html (en incluant les commandes R, les sorties et les graphes). Le nouveau document créé sera sauvegardé avec l’extension ” .Rmd”. Lors de la création, il faut préciser le type de document final souhaité (document au format HTML ou PDF ou presentation, etc), ainsi que les informations du document (titre et auteur). On reviendra plus précisément sur les possibilités offertes par Rmarkdown et les commandes principales pour débuter la rédaction d’un rapport dans le tutoriel 4 de R avancé.\nVous pouvez aussi créer un document à l’aide de Quarto en sélectionnant Quarto Document et vous avez la possibilité de l’éditer au format pdf ou html également. Le nouveau document créé sera sauvegardé avec l’extension ” .qmd”. La syntaxe d’un document quarto est proche de celle en Rmarkdown, on y reviendra dans le tutoriel 4."
  },
  {
    "objectID": "Part1-Intro.html#environnement",
    "href": "Part1-Intro.html#environnement",
    "title": "1  Démarrer avec R et découverte de RStudio",
    "section": "1.3 Environnement",
    "text": "1.3 Environnement\n\n1.3.1 Répertoire de travail\nPour pouvoir récupérer des données, maîtriser la sauvegarde des scripts, des résultats, … il est important de connaitre le répertoire de travail c’est-à-dire le répertoire sous lequel les divers résultats seront sauvegardés par défaut. Ce dernier s’obtient à l’aide de la commande getwd().\nPour changer de répertoire de travail, on peut utiliser la commande setwd() dans la Console. A noter que R ne reconnaît que le caractère “/” pour spécifier le chemin d’accès d’un répertoire (même sous Windows). On peut aussi passer par Session -&gt; Set Working Directory -&gt; Choose Directory.\n\n\n1.3.2 L’aide de R\nIl est normal de ne pas savoir (ou d’avoir oublié) quels sont les arguments d’une fonction, ou comment ils se nomment. On peut à tout moment faire appel à l’aide intégrée de R. On peut accéder à l’aide pour une fonction (ex pour la fonction plot) en passant le nom de la fonction dans help() (ex help(plot)) ou en utilisant le raccourci ?plot. Ces deux commandes permettent d’afficher une page de description (en anglais) de la fonction, ses paramètres, son résultat, d’exemples, … Ces pages d’aide contiennent de nombreuses informations mais elles ne sont pas toujours d’une lecture aisée. Dans RStudio, les pages d’aide en ligne s’ouvriront par défaut dans la zone en bas à droite, sous l’onglet Help. Un clic sur l’icône en forme de maison vous affichera la page d’accueil de l’aide. Vous pouvez aussi taper directement le nom de la fonction recherchée dans la zone de recherche dans l’onglet Help.\n\n\n1.3.3 Les librairies pour R\nR est un logiciel libre, il s’enrichit grâce au développement de packages par la communauté. La plupart des extensions sont développées et maintenues par la communauté des utilisateurs de R, et diffusées via un réseau de serveurs nommé CRAN (Comprehensive R Archive Network). On peut également trouver des packages R dédiés à l’étude des données génomiques à haut-débit sur Bioconductor, des packages déposés sur github, …\nPour installer une librairie disponible sur le CRAN, vous avez plusieurs manières de le faire :\n\npasser par le menu Tools-&gt; Install Packages ... et sélectionner un site miroir du CRAN\nAller dans l’onglet Packages dans la fenêtre en bas à droite et cliquer sur Install.\nutiliser la fonction install.packages() directement dans la console\ntélécharger l’archive .zip correspondant au package et utiliser ensuite Tools-&gt; Install Packages ..., choisir Package Archive File (.tar,.zip) dans Install form.\n\ninstaller directement dans un terminal (sans utiliser RStudio) avec la commande R CMD INSTALL package-name.tar.gz.\n\nAttention, vous devez posséder une version de R qui permette l’installation du package désiré et certains packages nécessitent l’installation préalable d’autres packages.\nPour l’installation d’un package de Bioconductor, il faut d’abord installer BiocManager install.packages(\"BiocManager\") puis on utilise la commande BiocManager::install().\nPour installer une librairie hébergée sur un dépot github, il faut d’abord installer le package devtools install.packages(\"devtools\"), charger cette librairie library(devtools) puis utiliser la commande install_github().\nToutes les librairies ne sont pas chargées automatiquement au lancement de R. Pour charger une librairie, on utilise la commande library() et les commandes search() ou searchpaths() pour connaître la liste des librairies chargées. Vous pouvez utiliser la commande .libPaths() pour connaitre les chemins vers lesquels pointe R pour trouver des librairies installées. Il faut aussi parfois mettre à jour les librairies. Pour cela, vous pouvez aller dans l’onglet Packages dans la fenêtre en bas à droite et cliquer sur l’icône Update, ou en utilisant la commande update.packages(...).\n\n\n1.3.4 Exercice\n\nEnoncéCorrection\n\n\n\nInstaller la dernière version de R et RStudio\nInstaller les packages suivants qui nous serviront par la suite : tidyverse, FactoMineR, mixOmics, corrplot, gridExtra, plotly, questionr\nCharger la librairie ggplot2, la librairie tidyverse. Y-a-t-il un lien entre les deux ?\n\nAccéder à la documentation de tidyverse, de la fonction rnorm.\n\n\n\nQuestion 1 : Voici pour les trois premiers, faire de même pour les autres.\n\ninstall.packages(\"FactoMineR\")\ninstall.packages(\"tidyverse\")\n\ninstall.packages(\"BiocManager\")\nBiocManager::install(\"mixOmics\")\n\nQuestion 2 :\n\nlibrary(ggplot2)\nlibrary(tidyverse)\n\nLe package tidyverse englobe plusieurs librairies dont ggplot2. On reviendra sur ce package tidyverse dans le tutoriel 4 de R avancé.\nQuestion 3 :\n\nhelp(tidyverse)\n? tidyverse\n\nhelp(rnorm)\n? rnorm"
  },
  {
    "objectID": "Part1-Intro.html#references",
    "href": "Part1-Intro.html#references",
    "title": "1  Démarrer avec R et découverte de RStudio",
    "section": "1.4 References",
    "text": "1.4 References"
  },
  {
    "objectID": "Part2-InitR.html#structure-des-objets",
    "href": "Part2-InitR.html#structure-des-objets",
    "title": "2  Initiation au langage et objets de R",
    "section": "2.1 Structure des objets",
    "text": "2.1 Structure des objets\nSous R, les éléments de base sont des objets : des données (vecteurs, matrices, …), des fonctions, des graphiques, … Ces objets se différencient par leur mode décrivant leur contenu, et leur classe décrivant leur structure. Les objets atomiques sont de mode homogène et les objets récursifs sont de mode hétérogène. Les différents modes sont null (objet vide), logical, numeric, complex, character.\nLes classes d’objets les plus courantes sont : vector, matrix, array, factor, data.frame, list. On peut avoir des vecteurs, matrices, tableaux, … de mode null (objet vide), logical (TRUE, FALSE, NA), numeric, complex, character. Par contre les listes et les tableaux peuvent être composés d’éléments hétérogènes. On utilise la commande class() pour connaître la classe d’un objet et str()pour connaitre la nature des éléments composant l’objet.\nLa principale difficulté en R réside dans l’identification des types d’objets manipulés. Nous allons dans ce tutoriel présenter ces différents objets, les opérations et manipulations basiques que l’on peut faire, …\nOn peut stocker un objet dans une variable (ex a) à l’aide de a&lt;- ... ou a= .... Pour lister les variables actuellement disponibles dans la session de travail, on utilise la fonction ls(). Pour effacer une ou plusieurs variables, on utilise la fonction rm(). La commande rm(list=ls()) permet d’effacer toutes les variables en mémoire.\n\n2.1.1 Opération sur les scalaires\n\nOpérationsis.xxx()/as.xxx()Arrondir\n\n\nLes opérations élémentaires sur les scalaires sont *,-, +, /, ^.\n\nSous R, tapez les commandes suivantes. Vous chercherez en particulier à bien identifier les différents types de données :\n\n2+2\nexp(10)\na = log(2)\na\nb =cos(10)\nb\na - b\na*b\nd &lt;- 2 &lt; 3\nd\ndd &lt;- FALSE\ndd - d\ndd + d\ne&lt;- \"toto\"\nclass(e)\nstr(e)\n\n\n\nPour tester si un objet obj est de type xxx, on utilise la commande is.xxx(obj). On peut aussi contraindre si possible l’objet obj au type xxx avec la commande as.xxx(obj).\n\na = 4.3\nis.numeric(a)\n\n[1] TRUE\n\nis.complex(a)\n\n[1] FALSE\n\nis.character(a)\n\n[1] FALSE\n\nas.character(a)\n\n[1] \"4.3\"\n\nb&lt;- \"toto\"\nis.numeric(b)\n\n[1] FALSE\n\nas.list(b)\n\n[[1]]\n[1] \"toto\"\n\n\n\n\nPour obtenir des valeurs arrondies sur des valeurs numériques, vous pouvez utiliser l’une des commandes suivantes round(), ceiling(), floor(), trunc() ou signif() (voir l’aide ?round). Comparez les codes suivantes:\n\na=1.3579\nfloor(a)\n\n[1] 1\n\nceiling(a)\n\n[1] 2\n\nround(a,digits=2)\n\n[1] 1.36\n\nsignif(a,digits=2)\n\n[1] 1.4\n\nis.integer(floor(a))\n\n[1] FALSE\n\nis.numeric(floor(a))\n\n[1] TRUE\n\n\n\n\n\n\n\n2.1.2 Booléens et opérations logiques\nEn R, un booléen est représenté par TRUE ou FALSE. Les opérations logiques, &lt;, &gt;, &lt;=, &gt;=, != (différent), == (égal) retournent TRUE ou FALSE. On peut définir plusieurs conditions à remplir avec les opérateurs & (ET) et | (OU).\nAttention, R considère qu’un booléen a FALSE vaut \\(0\\) et qu’un booléen a TRUE vaut \\(1\\). Il est donc capable d’évaluer TRUE + 5 bien qu’en toute logique, cela n’a aucun sens!\n\nVoici quelques exemples de manipulation des booléens :\n\na = 3\nb = 6\na&lt;=b\n\n[1] TRUE\n\na!=b\n\n[1] TRUE\n\n(b-3==a) & (b&gt;=a)\n\n[1] TRUE\n\n(b==a) | (b&gt;=a)\n\n[1] TRUE\n\n\n\n\n2.1.3 Les caractères\nOn donne ici quelques fonctions de base sur la manipulation des chaînes de caractères. Dans le tutoriel 4 de R avancé, on présentera le package stringr qui est très utilisé pour gérer et manipuler des chaînes de caractères.\n\npaste()nchar()substr() / substring()strsplit()grep()gsub()\n\n\nPour concaténer, juxtaposer des chaînes de caractères on utilise la fonction paste()\n\nEx = paste(\"Bonjour\", \"à\",\"toutes\",\"et\",\"tous\",\"!\")\npaste(\"Bonjour\", \"à\",\"toutes\",\"et\",\"tous\",\"!\",sep=\"_\")\n\n[1] \"Bonjour_à_toutes_et_tous_!\"\n\nx = c(\"Bonjour\", \"à\", \"vous\")\npaste(x)\n\n[1] \"Bonjour\" \"à\"       \"vous\"   \n\npaste(x,collapse=\"++\")\n\n[1] \"Bonjour++à++vous\"\n\n\n\n\nOn accède à la longueur d’une chaîne avec la fonction nchar()\n\nnchar(Ex)\n\n[1] 26\n\n\n\n\nLa fonction substr() permet d’extraire une partie d’une chaîne à partir des attributs « start » et « stop ». On peut aussi remplacer des segments d’une chaine.\n\nsubstr(Ex,start=3,stop=9)\n\n[1] \"njour à\"\n\nsubstr(Ex, start = 3, stop = 9) &lt;- \"@@@\"\nEx\n\n[1] \"Bo@@@ur à toutes et tous !\"\n\n\nOn peut aussi utiliser la fonction substring()\n\nEx = paste(\"Bonjour\", \"à\",\"toutes\",\"et\",\"tous\",\"!\")\nsubstring(Ex, first = 3)\n\n[1] \"njour à toutes et tous !\"\n\nsubstring(Ex, first = 3, last = 9) &lt;- \"@@@--&lt;\"\nEx\n\n[1] \"Bo@@@--&lt;à toutes et tous !\"\n\n\n\n\nLa fonction strsplit() permet de scinder une chaîne de caractères :\n\nEx = paste(\"Bonjour\", \"à\",\"toutes\",\"et\",\"tous\",\"!\")\nstrsplit(Ex,split= \" \")\n\n[[1]]\n[1] \"Bonjour\" \"à\"       \"toutes\"  \"et\"      \"tous\"    \"!\"      \n\nstrsplit(Ex,split=c(\"o\",\" \"))\n\n[[1]]\n[1] \"B\"         \"nj\"        \"ur à t\"    \"utes et t\" \"us !\"     \n\n\nLa sortie de la fonction strsplit() est une liste (voir section sur list)\n\n\nLa fonction grep() permet de rechercher les éléments d’une liste.\n\nEx1 = c(\"tomate\",\"concombre\",\"mais\",\"courgette\",\"poivron\",\"carotte\",\"betterave\")\nEx1\n\n[1] \"tomate\"    \"concombre\" \"mais\"      \"courgette\" \"poivron\"   \"carotte\"  \n[7] \"betterave\"\n\ngrep(pattern=\"o\",Ex1,value=FALSE) # donne les indices des éléments contenant un \"o\" dans Ex\n\n[1] 1 2 4 5 6\n\ngrep(pattern=\"o\",Ex1, value = TRUE) # Donne les éléments de Ex1 qui contiennent la lettre \"o\"\n\n[1] \"tomate\"    \"concombre\" \"courgette\" \"poivron\"   \"carotte\"  \n\n\nOn peut utiliser la fonction grep() avec les expressions régulières disponible sous R, il faut penser à mettre l’option fixed=FALSE. Pour plus de détail, voir ?regex.\n\n\nEnfin pour remplacer un pattern dans une chaine de caractère, on peut utiliser la fonction gsub()\n\ngsub(pattern = \"o\" , replacement = \"@\" , Ex1, fixed = TRUE)\n\n[1] \"t@mate\"    \"c@nc@mbre\" \"mais\"      \"c@urgette\" \"p@ivr@n\"   \"car@tte\"  \n[7] \"betterave\"\n\n\n\n\n\n\n\n2.1.4 Vecteurs (vector)\nUn vecteur est un ensemble ordonné d’éléments de même nature (numérique, logique ou alphanumérique). La création d’un vecteur peut se faire par la commande c(e1,e2,...). On peut également générer une séquence avec la commande seq(a,b,t) où \\(a\\) est le premier terme, le dernier terme est \\(\\leq b\\) et le pas est \\(t\\). Pour créer un vecteur constitué de l’élément \\(x\\) répété \\(n\\) fois, on utilise la commande rep(x,n).\nOn donne ici quelques exemples à tester sous R pour vous familiariser avec les vecteurs. En particulier, vous pouvez découvrir des fonctions utiles avec les vecteurs comme length(), sum(), sort(), … , les opérations usuelles, l’extraction d’éléments d’un vecteur, …\n\nCommande c(...)Commande seq(...)Commande rep(...)Extraire des élémentsOpérationsFonctions usuelles\n\n\n\nd &lt;- c(2,3,5,8,4,6)\nd\n\n[1] 2 3 5 8 4 6\n\nis.vector(d)\n\n[1] TRUE\n\nc(2,5,\"toto\")\n\n[1] \"2\"    \"5\"    \"toto\"\n\n1:10\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\n\n\n\nseq(1,10)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\nseq(from=1,to=20,by=2) \n\n [1]  1  3  5  7  9 11 13 15 17 19\n\nseq(1,20,by=5)\n\n[1]  1  6 11 16\n\nseq(1,20,length=5)\n\n[1]  1.00  5.75 10.50 15.25 20.00\n\n\n\n\n\nrep(5,times=10)\n\n [1] 5 5 5 5 5 5 5 5 5 5\n\nrep(c(1,2),3)\n\n[1] 1 2 1 2 1 2\n\nrep(c(1,2),each=3)\n\n[1] 1 1 1 2 2 2\n\n\n\n\n\nd\n\n[1] 2 3 5 8 4 6\n\nd[2]\n\n[1] 3\n\nd[2:3]\n\n[1] 3 5\n\nd[c(1,3,6)]\n\n[1] 2 5 6\n\nd[-3]\n\n[1] 2 3 8 4 6\n\nd[-(1:2)]\n\n[1] 5 8 4 6\n\n\n\n\nAdditionner ou soustraire un scalaire d’un vecteur\n\nd+4\n\n[1]  6  7  9 12  8 10\n\nd-4\n\n[1] -2 -1  1  4  0  2\n\n\nMultiplier ou diviser un vecteur par un scalaire\n\n2*d\n\n[1]  4  6 10 16  8 12\n\nd/3\n\n[1] 0.6666667 1.0000000 1.6666667 2.6666667 1.3333333 2.0000000\n\n\nMultiplier/ diviser deux vecteurs terme à terme\n\ne&lt;- rep(2,6)\nd*e\n\n[1]  4  6 10 16  8 12\n\nd/e\n\n[1] 1.0 1.5 2.5 4.0 2.0 3.0\n\n\n\n\n\nd = c(2,3,5,8,4,6)\nd\n\n[1] 2 3 5 8 4 6\n\n\nLongueur d’un vecteur\n\nlength(d)\n\n[1] 6\n\n\nSomme des termes d’un vecteur numérique\n\nsum(d)\n\n[1] 28\n\n\nSomme des termes cumulés d’un vecteur numérique\n\ncumsum(d)\n\n[1]  2  5 10 18 22 28\n\n\nDifférence des termes successifs d’un vecteur numérique\n\ndiff(d)\n\n[1]  1  2  3 -4  2\n\n\nVérifier si d est un vecteur\n\nis.vector(d)\n\n[1] TRUE\n\n\nTransposition d’un vecteur\n\nt(d)\n\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,]    2    3    5    8    4    6\n\n\nProduit scalaire\n\nt(d)%*%e\n\n     [,1]\n[1,]   56\n\n\nNA (Not Available) signale une donnée manquante\n\nd[3] &lt;- NA\nd\n\n[1]  2  3 NA  8  4  6\n\nis.na(d)\n\n[1] FALSE FALSE  TRUE FALSE FALSE FALSE\n\nany(is.na(d))\n\n[1] TRUE\n\nall(is.na(d))\n\n[1] FALSE\n\n\nAutres fonctions intéressantes avec les vecteurs : abs(), sort(), order(), which(), …\n\na&lt;-c(3,-1,5,2,-7,3,9)\nabs(a)\n\n[1] 3 1 5 2 7 3 9\n\nsort(a)\n\n[1] -7 -1  2  3  3  5  9\n\norder(a)\n\n[1] 5 2 4 1 6 3 7\n\n\n\nb = a==3\nb\n\n[1]  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE\n\nsort(b)\n\n[1] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE\n\n\n\ntext&lt;-c(\"petit\",\"moyen\",\"grand\")\nis.vector(text)\n\n[1] TRUE\n\n\n\nf = c(a=12,b=26,c=32,d=41)\nf\n\n a  b  c  d \n12 26 32 41 \n\nnames(f)\n\n[1] \"a\" \"b\" \"c\" \"d\"\n\nf[\"a\"]\n\n a \n12 \n\nnames(f)&lt;-c(\"a1\",\"a2\",\"a3\",\"a4\")\nf\n\na1 a2 a3 a4 \n12 26 32 41 \n\n\nNotez la différence entre les commandes suivantes :\n\nf&gt;30\n\n   a1    a2    a3    a4 \nFALSE FALSE  TRUE  TRUE \n\nf[f&gt;30]\n\na3 a4 \n32 41 \n\nwhich(f&gt;30)\n\na3 a4 \n 3  4 \n\n\n\nf[2] &lt;- 22\nf+100\n\n a1  a2  a3  a4 \n112 122 132 141 \n\n\nEtonnant ces commandes suivantes, non ?\n\nf\n\na1 a2 a3 a4 \n12 22 32 41 \n\nd\n\n[1]  2  3 NA  8  4  6\n\nf+d\n\n[1] 14 25 NA 49 16 28\n\n\nOn peut appliquer une fonction à tous les éléments d’un vecteur facilement.\n\ncos(f)\n\n        a1         a2         a3         a4 \n 0.8438540 -0.9999608  0.8342234 -0.9873393 \n\n\n\n\n\n\nExercice\n\nEnoncéCorrection\n\n\nQuestion 1 : Créer les vecteurs suivants :\n\nle vecteur \\(a\\) constitué des entiers pairs jusqu’à 30\nle vecteur \\(b\\) contenant \\(v=5\\), deux fois la valeur de \\(v\\), puis un tiers de la valeur de \\(v\\), puis trois fois \\(v^2\\), puis \\(\\sqrt{v}\\), puis le quatrième élément de \\(a\\).\nle vecteur \\(c\\) contenant 6 chiffres compris entre 4 et 30 avec un intervalle constant.\nle vecteur \\(d\\) contenant la somme des éléments de \\(c\\), puis la longueur de \\(b\\), puis 5 fois le chiffre 3.\n\nQuestion 2 : Extraire du vecteur \\(a\\) :\n\nle quatrième élément\ntous les éléments sauf le quatrième\ntous les éléments supérieurs à 10\n\nQuestion 3 : À quoi sert la fonction unique ? Illustrer son fonctionnement sur un exemple.\n\n\nQuestion 1 :\n\na = seq(2,30,2) \na\n\n [1]  2  4  6  8 10 12 14 16 18 20 22 24 26 28 30\n\nv = 5\nb = c(v,2*v,v/3,3*(v^2),sqrt(v),a[4])\nb\n\n[1]  5.000000 10.000000  1.666667 75.000000  2.236068  8.000000\n\nc = seq(4,30,length=6)\nc\n\n[1]  4.0  9.2 14.4 19.6 24.8 30.0\n\nd = c(sum(c),length(b),rep(3,5))\nd\n\n[1] 102   6   3   3   3   3   3\n\n\nQuestion 2 :\n\na[4]\n\n[1] 8\n\na[-4]\n\n [1]  2  4  6 10 12 14 16 18 20 22 24 26 28 30\n\na[a&gt;10]\n\n [1] 12 14 16 18 20 22 24 26 28 30\n\n\nQuestion 3 :\n\nhelp(unique)\nunique(d)\n\n[1] 102   6   3\n\n\nLa fonction unique() permet de récupérer les éléments d’un vecteur (et pas que) sans réplication.\n\n\n\n\n\n\n2.1.5 Matrices (matrix)\nComme les vecteurs, les matrices sont de mode quelconque mais ne contiennent que des éléments de même nature. Pour créer une matrice, on utilise la commande matrix(vec,nrow=n,ncol=p) où vec est le vecteur contenant les éléments de la matrice de taille \\(n\\) par \\(p\\), qui seront rangés en colonne sauf si l’option byrow=T est utilisée.\nOn donne ici quelques exemples à tester sous R pour vous familiariser avec les matrices. En particulier, vous pouvez découvrir des fonctions utiles avec les matrices comme dim(), t(), cbind(), rbind()… , les opérations usuelles dont la différence entre A*B et A%*%B, l’extraction d’éléments d’une matrice, …\n\nmatrix()Extrairecbind() / rbind()Fonctions utilesOpérations\n\n\n\nA = matrix(1:15,ncol=5)\nA\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    4    7   10   13\n[2,]    2    5    8   11   14\n[3,]    3    6    9   12   15\n\nclass(A)\n\n[1] \"matrix\" \"array\" \n\nB = matrix(1:15,nc=5,byrow=T)\nB2 = B\nB2[1,1]=\"toto\"\nB2\n\n     [,1]   [,2] [,3] [,4] [,5]\n[1,] \"toto\" \"2\"  \"3\"  \"4\"  \"5\" \n[2,] \"6\"    \"7\"  \"8\"  \"9\"  \"10\"\n[3,] \"11\"   \"12\" \"13\" \"14\" \"15\"\n\n\n\nrownames(A)=c(paste(\"ligne\",1:3,sep=\"\"))\nA\n\n       [,1] [,2] [,3] [,4] [,5]\nligne1    1    4    7   10   13\nligne2    2    5    8   11   14\nligne3    3    6    9   12   15\n\n\n\n\n\nA\n\n       [,1] [,2] [,3] [,4] [,5]\nligne1    1    4    7   10   13\nligne2    2    5    8   11   14\nligne3    3    6    9   12   15\n\nA[1,3]\n\nligne1 \n     7 \n\nA[,2]\n\nligne1 ligne2 ligne3 \n     4      5      6 \n\nA[2,]\n\n[1]  2  5  8 11 14\n\nA[1:3,c(2,5)]\n\n       [,1] [,2]\nligne1    4   13\nligne2    5   14\nligne3    6   15\n\nA[1:3,-c(2,5)]\n\n       [,1] [,2] [,3]\nligne1    1    7   10\nligne2    2    8   11\nligne3    3    9   12\n\n\n\n\nPour concaténer deux matrices, on peut utiliser les fonctions rbind() ou cbind().\n\nA\n\n       [,1] [,2] [,3] [,4] [,5]\nligne1    1    4    7   10   13\nligne2    2    5    8   11   14\nligne3    3    6    9   12   15\n\nB\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    2    3    4    5\n[2,]    6    7    8    9   10\n[3,]   11   12   13   14   15\n\ncbind(A,B)\n\n       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\nligne1    1    4    7   10   13    1    2    3    4     5\nligne2    2    5    8   11   14    6    7    8    9    10\nligne3    3    6    9   12   15   11   12   13   14    15\n\nrbind(A,B)\n\n       [,1] [,2] [,3] [,4] [,5]\nligne1    1    4    7   10   13\nligne2    2    5    8   11   14\nligne3    3    6    9   12   15\n          1    2    3    4    5\n          6    7    8    9   10\n         11   12   13   14   15\n\n\n\n\nDimension d’une matrice\n\ndim(A)\n\n[1] 3 5\n\n\nNombre de lignes et de colonnes\n\nnrow(A)\n\n[1] 3\n\nncol(A)\n\n[1] 5\n\n\nTransposée et déterminant d’une matrice\n\nt(A)\n\n     ligne1 ligne2 ligne3\n[1,]      1      2      3\n[2,]      4      5      6\n[3,]      7      8      9\n[4,]     10     11     12\n[5,]     13     14     15\n\ndet(A[,3:5])\n\n[1] 0\n\n\nInversion d’une matrice\n\nsolve(A[1:2,2:3])\n\n        ligne1    ligne2\n[1,] -2.666667  2.333333\n[2,]  1.666667 -1.333333\n\n\nMatrice diagonale et diagonale d’une matrice\n\ndiag(A)\n\n[1] 1 5 9\n\ndiag(1:5)\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    0    0    0    0\n[2,]    0    2    0    0    0\n[3,]    0    0    3    0    0\n[4,]    0    0    0    4    0\n[5,]    0    0    0    0    5\n\n\nMatrice de booléens\n\nA&gt;5\n\n        [,1]  [,2] [,3] [,4] [,5]\nligne1 FALSE FALSE TRUE TRUE TRUE\nligne2 FALSE FALSE TRUE TRUE TRUE\nligne3 FALSE  TRUE TRUE TRUE TRUE\n\nA[A&lt;5]&lt;-0\nA\n\n       [,1] [,2] [,3] [,4] [,5]\nligne1    0    0    7   10   13\nligne2    0    5    8   11   14\nligne3    0    6    9   12   15\n\n\nQuelques autres fonctions sur les matrices\n\ncolSums(A)\n\n[1]  0 11 24 33 42\n\napply(A,2,sum)\n\n[1]  0 11 24 33 42\n\nrowSums(A)\n\nligne1 ligne2 ligne3 \n    30     38     42 \n\napply(A,1,sum)\n\nligne1 ligne2 ligne3 \n    30     38     42 \n\nrowMeans(A)\n\nligne1 ligne2 ligne3 \n   6.0    7.6    8.4 \n\napply(A,1,mean)\n\nligne1 ligne2 ligne3 \n   6.0    7.6    8.4 \n\napply(A,1,max)\n\nligne1 ligne2 ligne3 \n    13     14     15 \n\n\nRemarque : on reverra dans la section Programmation la fonction apply() qui permet en particulier d’éviter les boucles for.\n\n\n\nAttention à la multiplication matricielle %*% et la multiplication terme à terme *!\nOpérations terme à terme de 2 matrices\n\nA+B\n\n       [,1] [,2] [,3] [,4] [,5]\nligne1    1    2   10   14   18\nligne2    6   12   16   20   24\nligne3   11   18   22   26   30\n\nA*B\n\n       [,1] [,2] [,3] [,4] [,5]\nligne1    0    0   21   40   65\nligne2    0   35   64   99  140\nligne3    0   72  117  168  225\n\n\nMultiplication de matrices\n\nt(B) %*%A\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    0   96  154  208  262\n[2,]    0  107  178  241  304\n[3,]    0  118  202  274  346\n[4,]    0  129  226  307  388\n[5,]    0  140  250  340  430\n\n\nMultiplication par un scalaire\n\n5*A\n\n       [,1] [,2] [,3] [,4] [,5]\nligne1    0    0   35   50   65\nligne2    0   25   40   55   70\nligne3    0   30   45   60   75\n\n\n\n\n\n\nExercice\n\nEnoncéCorrection\n\n\n\nCréer la matrice \\(A=\\left(\\begin{array}{c c c } 3 & 3 & 3\\\\ 4 & 4 & 4\\\\ 5 & 5 & 5\\end{array}\\right).\\)\nAjouter 2 à tous les éléments de \\(A\\).\nCréer la matrice \\(B\\) en ajoutant la ligne \\((1,2,3)\\) à \\(A\\), puis la colonne \\((1,1,1,1)'\\). Déterminer la dimension de \\(B\\).\nExtraire de \\(B\\) la sous-matrice \\(C\\) composée des deux premières colonnes et des deux dernières lignes. Calculer sa transposée et son déterminant. Inverser cette sous-matrice \\(C\\).\n\n\n\nQuestion 1\n\nA = matrix(c(rep(3,3),rep(4,3),rep(5,3)),nrow=3,byrow=T)\nA\n\n     [,1] [,2] [,3]\n[1,]    3    3    3\n[2,]    4    4    4\n[3,]    5    5    5\n\n\nQuestion 2\n\nA+2\n\n     [,1] [,2] [,3]\n[1,]    5    5    5\n[2,]    6    6    6\n[3,]    7    7    7\n\n\nQuestion 3\n\nB = rbind(A,1:3)\nB = cbind(B,rep(1,4))\ndim(B)\n\n[1] 4 4\n\nB\n\n     [,1] [,2] [,3] [,4]\n[1,]    3    3    3    1\n[2,]    4    4    4    1\n[3,]    5    5    5    1\n[4,]    1    2    3    1\n\n\nQuestion 4\n\nC = B[3:4,1:2]\nC\n\n     [,1] [,2]\n[1,]    5    5\n[2,]    1    2\n\nt(C)\n\n     [,1] [,2]\n[1,]    5    1\n[2,]    5    2\n\ndet(C)\n\n[1] 5\n\nsolve(C)\n\n     [,1] [,2]\n[1,]  0.4   -1\n[2,] -0.2    1\n\nC%*%solve(C)\n\n     [,1] [,2]\n[1,]    1    0\n[2,]    0    1\n\n\n\n\n\n\n\n\n2.1.6 Les tableaux (array)\nLes tableaux sont des matrices de dimensions supérieures à 2. On peut les générer à partir de la commande array(vec,c(n,p,q,...)) où vec est le vecteur contenant les éléments du tableau et l’argument c(n,p,q,…) désigne les dimensions du tableau: \\(n\\) lignes, \\(p\\) colonnes, \\(q\\) matrices, …\n\narray()Fonctions usuellesapply()\n\n\n\nE=array(c(1:8,rep(1,8),seq(0,1,len=8)),dim = c(2,4,3))\nE\n\n, , 1\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    3    5    7\n[2,]    2    4    6    8\n\n, , 2\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    1    1    1\n[2,]    1    1    1    1\n\n, , 3\n\n          [,1]      [,2]      [,3]      [,4]\n[1,] 0.0000000 0.2857143 0.5714286 0.8571429\n[2,] 0.1428571 0.4285714 0.7142857 1.0000000\n\nE[, , 1]\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    3    5    7\n[2,]    2    4    6    8\n\n\n\n\n\ndim(E)\n\n[1] 2 4 3\n\nlength(E)\n\n[1] 24\n\nnrow(E)\n\n[1] 2\n\nncol(E)\n\n[1] 4\n\naperm(E)\n\n, , 1\n\n     [,1]      [,2]      [,3]      [,4]\n[1,]    1 3.0000000 5.0000000 7.0000000\n[2,]    1 1.0000000 1.0000000 1.0000000\n[3,]    0 0.2857143 0.5714286 0.8571429\n\n, , 2\n\n          [,1]      [,2]      [,3] [,4]\n[1,] 2.0000000 4.0000000 6.0000000    8\n[2,] 1.0000000 1.0000000 1.0000000    1\n[3,] 0.1428571 0.4285714 0.7142857    1\n\nE+10\n\n, , 1\n\n     [,1] [,2] [,3] [,4]\n[1,]   11   13   15   17\n[2,]   12   14   16   18\n\n, , 2\n\n     [,1] [,2] [,3] [,4]\n[1,]   11   11   11   11\n[2,]   11   11   11   11\n\n, , 3\n\n         [,1]     [,2]     [,3]     [,4]\n[1,] 10.00000 10.28571 10.57143 10.85714\n[2,] 10.14286 10.42857 10.71429 11.00000\n\n\n\n\n\nH = array(1:12,c(2,3,2))\nH\n\n, , 1\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n, , 2\n\n     [,1] [,2] [,3]\n[1,]    7    9   11\n[2,]    8   10   12\n\n\n\n\n\n\n\nReprésentation de H\n\n\n\n\n\napply(H,1,sum)\n\n[1] 36 42\n\nsum(c(1,3,5,7,9,11))\n\n[1] 36\n\n\n\napply(H,2,sum)\n\n[1] 18 26 34\n\nsum(c(1,2,7,8))\n\n[1] 18\n\n\n\napply(H,3,sum)\n\n[1] 21 57\n\nsum(1:6)\n\n[1] 21\n\n\n\n\n\n\n\n\n2.1.7 Listes (list)\nUne liste est une collection ordonnée d’objets qui peuvent être de nature différente. Les listes sont en particulier utilisées par certaines fonctions (cf section Programmation) pour renvoyer des résultats complexes sous forme d’un seul objet. On utilise la fonction list(nom1=el1,nom2=el2,...) (l’utilisation des noms étant facultative) pour générer une liste. On peut accéder à chaque élément de la liste à l’aide de son index entre double crochets [[...]], ou par son nom précédé du signe $.\n\nlist(...)ExtractionFonctions utiles\n\n\n\nx = list(\"toto\",1:8)\nx\n\n[[1]]\n[1] \"toto\"\n\n[[2]]\n[1] 1 2 3 4 5 6 7 8\n\nclass(x)\n\n[1] \"list\"\n\n\nCréation d’une liste avec des noms aux éléments\n\ny = list(matrice=matrix(1:15,ncol=5),\n         vecteur=seq(1,20,by=5),\n         texte=\"toto\",scalaire=8)\ny\n\n$matrice\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    4    7   10   13\n[2,]    2    5    8   11   14\n[3,]    3    6    9   12   15\n\n$vecteur\n[1]  1  6 11 16\n\n$texte\n[1] \"toto\"\n\n$scalaire\n[1] 8\n\n\n\n\nExtraction d’un élément par son numéro\n\nx[[1]]\n\n[1] \"toto\"\n\n\nAttention, cette commande n’est pas possible:\n\nx[[1]]+1\n\npar contre celle-ci est possible\n\nx[[2]]+10\n\n[1] 11 12 13 14 15 16 17 18\n\n\n\ny[[1]]\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    4    7   10   13\n[2,]    2    5    8   11   14\n[3,]    3    6    9   12   15\n\ny$matrice\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    4    7   10   13\n[2,]    2    5    8   11   14\n[3,]    3    6    9   12   15\n\ny$vec\n\n[1]  1  6 11 16\n\ny[c(\"texte\",\"scalaire\")]\n\n$texte\n[1] \"toto\"\n\n$scalaire\n[1] 8\n\n\n\n\n\nnames(y)\n\n[1] \"matrice\"  \"vecteur\"  \"texte\"    \"scalaire\"\n\nlength(y)\n\n[1] 4\n\nlength(y$vecteur)\n\n[1] 4\n\ncos(y$scal)+y[[2]][1]\n\n[1] 0.8545\n\nsummary(y)\n\n         Length Class  Mode     \nmatrice  15     -none- numeric  \nvecteur   4     -none- numeric  \ntexte     1     -none- character\nscalaire  1     -none- numeric  \n\n\n\n\n\n\nExercice\n\nEnoncéCorrection\n\n\n\nCréer une liste contenant le nom de trois matières, les notes de 5 élèves pour chacune de ces matières, l’âge des 5 élèves et la filière (PO) d’appartenance de ces 5 élèves.\nRécupérer les notes du 4ème élève\nCréer une matrice contenant les notes et l’âge des 5 élèves.\n\n\n\n\nmatiere = c(\"Maths\", \"Chimie\", \"Sport\")\nage=c(20,21,22,23,24)\nPO=c(\"MIC\",\"IMACS\",\"MIC\",\"MIC\",\"IC\")\nNotes=matrix(c(15,12,1,14,12,6,3,14,12,16,11,12,13,14,15),nrow=5)\nA = list(matieres=matiere,Notes=Notes,Age=age,PO=PO)\nA\n\n$matieres\n[1] \"Maths\"  \"Chimie\" \"Sport\" \n\n$Notes\n     [,1] [,2] [,3]\n[1,]   15    6   11\n[2,]   12    3   12\n[3,]    1   14   13\n[4,]   14   12   14\n[5,]   12   16   15\n\n$Age\n[1] 20 21 22 23 24\n\n$PO\n[1] \"MIC\"   \"IMACS\" \"MIC\"   \"MIC\"   \"IC\"   \n\nA$Notes[4,]\n\n[1] 14 12 14\n\nB = cbind(A$Notes,A$Age)\nB\n\n     [,1] [,2] [,3] [,4]\n[1,]   15    6   11   20\n[2,]   12    3   12   21\n[3,]    1   14   13   22\n[4,]   14   12   14   23\n[5,]   12   16   15   24\n\n\n\n\n\n\n\n\n2.1.8 Data frames\nSous R, un data.frame est analogue à une matrice mais le contenu des colonnes peut être ici hétérogène. Un tableau de données est un ensemble de vecteurs rangés colonne par colonne, chaque colonne correspondant à une variable, chaque ligne à un individu. En particulier, lors d’études statistiques, les données à étudier sont souvent représentées par un data.frame sous R. Pour créer un tableau de données, on peut regrouper des variables de même longueur à l’aide de la commande data.frame(nom1=var1,nom2=var2,...). On peut par exemple transformer une matrice en un tableau de données en utilisant la commande as.data.frame(mat).\nOn donne ici quelques exemples à tester sous R pour vous familiariser avec les data.frames. En particulier, vous pouvez découvrir des fonctions utiles dont summary(), attach(), …\n\ndata.frame()summary()/head()data.frame / list/matrixattach()/detach()\n\n\n\n# Création du data.frame H\ntaille = runif(12,150,180)\nmasse = runif(12,50,90)\nsexe = rep(c(\"M\",\"F\",\"F\",\"M\"),3)\nH = data.frame(taille,masse,sexe)\nH\n\n     taille    masse sexe\n1  164.3085 62.60428    M\n2  166.2723 68.14572    F\n3  179.3116 72.79779    F\n4  165.6578 58.95325    M\n5  172.6767 76.80781    M\n6  164.8161 51.79686    F\n7  170.0047 72.07851    F\n8  179.0231 80.38639    M\n9  175.4738 86.58658    M\n10 151.0071 85.43481    F\n11 161.5747 54.38693    F\n12 159.8848 55.56110    M\n\nclass(H)\n\n[1] \"data.frame\"\n\n\n\n\nLa fonction summary() permet de résumer le contenu des différentes colonnes d’un data.frame.\n\nsummary(H)\n\n     taille          masse           sexe          \n Min.   :151.0   Min.   :51.80   Length:12         \n 1st Qu.:163.6   1st Qu.:58.11   Class :character  \n Median :166.0   Median :70.11   Mode  :character  \n Mean   :167.5   Mean   :68.80                     \n 3rd Qu.:173.4   3rd Qu.:77.70                     \n Max.   :179.3   Max.   :86.59                     \n\n\nLa fonction head() permet de visualiser les premières lignes d’un data.frame\n\nhead(H)\n\n    taille    masse sexe\n1 164.3085 62.60428    M\n2 166.2723 68.14572    F\n3 179.3116 72.79779    F\n4 165.6578 58.95325    M\n5 172.6767 76.80781    M\n6 164.8161 51.79686    F\n\n\n\n\nAu travers de ces quelques commandes, vous pouvez voir les analogies entre data.frame, list et matrix mais restez prudent sur la nature de l’objet que vous manipulez!\n\nH[1,]\n\n    taille    masse sexe\n1 164.3085 62.60428    M\n\nH$taille\n\n [1] 164.3085 166.2723 179.3116 165.6578 172.6767 164.8161 170.0047 179.0231\n [9] 175.4738 151.0071 161.5747 159.8848\n\nH$sexe\n\n [1] \"M\" \"F\" \"F\" \"M\" \"M\" \"F\" \"F\" \"M\" \"M\" \"F\" \"F\" \"M\"\n\nis.data.frame(H)\n\n[1] TRUE\n\nis.matrix(H)\n\n[1] FALSE\n\nMH = as.matrix(H)\nMH\n\n      taille     masse      sexe\n [1,] \"164.3085\" \"62.60428\" \"M\" \n [2,] \"166.2723\" \"68.14572\" \"F\" \n [3,] \"179.3116\" \"72.79779\" \"F\" \n [4,] \"165.6578\" \"58.95325\" \"M\" \n [5,] \"172.6767\" \"76.80781\" \"M\" \n [6,] \"164.8161\" \"51.79686\" \"F\" \n [7,] \"170.0047\" \"72.07851\" \"F\" \n [8,] \"179.0231\" \"80.38639\" \"M\" \n [9,] \"175.4738\" \"86.58658\" \"M\" \n[10,] \"151.0071\" \"85.43481\" \"F\" \n[11,] \"161.5747\" \"54.38693\" \"F\" \n[12,] \"159.8848\" \"55.56110\" \"M\" \n\nsummary(MH)\n\n    taille             masse               sexe          \n Length:12          Length:12          Length:12         \n Class :character   Class :character   Class :character  \n Mode  :character   Mode  :character   Mode  :character  \n\nas.list(H)\n\n$taille\n [1] 164.3085 166.2723 179.3116 165.6578 172.6767 164.8161 170.0047 179.0231\n [9] 175.4738 151.0071 161.5747 159.8848\n\n$masse\n [1] 62.60428 68.14572 72.79779 58.95325 76.80781 51.79686 72.07851 80.38639\n [9] 86.58658 85.43481 54.38693 55.56110\n\n$sexe\n [1] \"M\" \"F\" \"F\" \"M\" \"M\" \"F\" \"F\" \"M\" \"M\" \"F\" \"F\" \"M\"\n\n\n\n\nLa fonction attach() permet d’accéder aux variables d’un data.frame sans appeler le data.frame.\nLa fonction detach() peut être utilisée pour supprimer la variable d’un data.frame, qui était précédemment attachée avec attach().\n\nrm(taille)\nH$taille\n\n [1] 164.3085 166.2723 179.3116 165.6578 172.6767 164.8161 170.0047 179.0231\n [9] 175.4738 151.0071 161.5747 159.8848\n\nattach(H)\n\nThe following objects are masked _by_ .GlobalEnv:\n\n    masse, sexe\n\ntaille\n\n [1] 164.3085 166.2723 179.3116 165.6578 172.6767 164.8161 170.0047 179.0231\n [9] 175.4738 151.0071 161.5747 159.8848\n\ndetach(H) # taille est alors introuvable\n\n\n\n\n\nExercice\n\nEnoncéCorrection\n\n\nOn reprend le data.frame \\(H\\) contruit dans la sous-section Exemple.\n\nExtraire la masse des individus dont la taille est supérieure à 160.\nExtraire la masse et le sexe de ces mêmes individus.\nExtraire la taille des individus de sexe masculin dont la masse est inférieure à 80 (c’est possible en une seule ligne avec &).\n\n\n\nQuestion 1\n\nH$masse[H$taille&gt;160]\n\n [1] 62.60428 68.14572 72.79779 58.95325 76.80781 51.79686 72.07851 80.38639\n [9] 86.58658 54.38693\n\nH[H$taille&gt;160,2]\n\n [1] 62.60428 68.14572 72.79779 58.95325 76.80781 51.79686 72.07851 80.38639\n [9] 86.58658 54.38693\n\n\nQuestion 2\n\nH[H$taille&gt;160,2:3]\n\n      masse sexe\n1  62.60428    M\n2  68.14572    F\n3  72.79779    F\n4  58.95325    M\n5  76.80781    M\n6  51.79686    F\n7  72.07851    F\n8  80.38639    M\n9  86.58658    M\n11 54.38693    F\n\nH[H$taille&gt;160,c(\"masse\",\"sexe\")]\n\n      masse sexe\n1  62.60428    M\n2  68.14572    F\n3  72.79779    F\n4  58.95325    M\n5  76.80781    M\n6  51.79686    F\n7  72.07851    F\n8  80.38639    M\n9  86.58658    M\n11 54.38693    F\n\n\nQuestion 3\n\nH$taille[H$sexe==\"M\" & H$masse&lt;80]\n\n[1] 164.3085 165.6578 172.6767 159.8848\n\nH[H$sexe==\"M\" & H$masse&lt;80,\"taille\"]\n\n[1] 164.3085 165.6578 172.6767 159.8848"
  },
  {
    "objectID": "Part2-InitR.html#premiers-graphiques",
    "href": "Part2-InitR.html#premiers-graphiques",
    "title": "2  Initiation au langage et objets de R",
    "section": "2.2 Premiers graphiques",
    "text": "2.2 Premiers graphiques\nNous allons dans cette partie présenter les bases des graphiques en R. Mais en pratique, on privilégie les graphiques construits à partir du package ggplot2. Une description des bases des graphiques avec ggplot2 est disponible dans le tutoriel 4 de R avancé.\n\n2.2.1 Gestion des fenêtres graphiques\nPour ouvrir une fenêtre graphique, on utilise x11() sous Unix, windows() sous Windows et quartz() sous MacOS X. La commande dev.list() permet de lister les fenêtres graphiques ouvertes. Il est important de clôturer une fenêtre graphique avec la commande dev.off().\nLa fonction split.screen permet de partitionner une fenêtre graphique active en plusieurs sous-fenêtres graphiques. Par exemple, split.screen(c(1,2)) divise la fenêtre graphique en 2 parties qu’on sélectionne avec screen(1) et screen(2). On peut également obtenir de telles partitions avec la commande layout ou l’option mfrow de la fonction par().\n\n\n2.2.2 Fonctions graphiques\nEn R il faut distinguer les fonctions graphiques principales qui créent une nouvelle fenêtre graphique lors de l’execution avec possibilité d’un titre, d’axes labélisés, … et les fonctions graphiques secondaires qui ont une action sur un graphique déjà existant.\n\nFonctions graphiques principales\nVoici une liste des fonctions principales les plus connues :\n\n\n\n\n\n\n\n\n\nFonction\nDescription\n\n\n\n\nplot(x)\ngraphe des valeurs de x (axe des y) ordonnées sur l’axe des x\n\n\nplot(x, y)\ngraphe bivarié de x (sur l’axe des x) et y (sur l’axe des y)\n\n\npie(x)\ngraphe en camembert\n\n\nboxplot(x)\ngraphe boites à moustaches\n\n\npairs(x)\nsi x est une matrice ou un tableau de données, dessine tous les graphes bivariés entre les colonnes de x\n\n\nhist(x)\nhistogramme des fréquences de x\n\n\nbarplot(x)\nhistogramme des valeurs de x\n\n\ncontour(x,y,z)\ncourbes de niveau (les données sont interpolées pour tracer les courbes), x et y doivent être des vecteurs et z une matrice telle que dim(z)=c(length(x), length(y))\n\n\nimage(x,y,z)\nidem mais les données sont représentées avec des couleurs\n\n\npersp(x,y,z)\nidem mais en perspective\n\n\n\n\n\nPour chaque fonction, les options peuvent être trouvées via l’aide. Certaines de ces options sont identiques pour plusieurs fonctions graphiques; voici les principales (avec leurs éventuelles valeurs par défaut) :\n\n\n\n\n\n\n\n\n\noption\nDescription\n\n\n\n\nadd=FALSE\nsi TRUE superpose le graphe au graphe existant (s’il y en a un)\n\n\naxes=TRUE\nsi FALSE ne trace pas les axes ni le cadre\n\n\ntype=\nle type de graphe qui sera dessiné, p : points, l : lignes, b : points connectés par des lignes, h : lignes verticales,o : idem mais les lignes recouvrent les points, s : escaliers, les données étant représentées par le sommet (par le bas) des lignes verticales\n\n\nxlim=,ylim=\nfixe les limites inférieures et supérieures des axes\n\n\nxlab=,ylab=\nannotations des axes (variables de mode caractère)\n\n\nmain=\ntitre principal (variable de mode caractère)\n\n\nsub=\nsous-titre (écrit dans une police plus petite)\n\n\n\n\n\n\n\nFonctions graphiques secondaires\nFonctions graphiques secondaires les plus connues :\n\n\n\n\n\n\n\n\n\nCode\nDescription\n\n\n\n\npoints(x,y)\najoute des points (l’option type= peut être utilisée)\n\n\nlines(x,y)\nidem mais avec des lignes\n\n\ntext(x,y,labels,…)\najoute le texte spécifié par labels aux coordonnées (x,y)\n\n\nsegments(x0,y0,x1,y1)\ntrace des lignes des points (x0,y0) aux points (x1,y1)\n\n\nabline(a,b)\ntrace une ligne de pente b et d’ordonnée à l’origine a\n\n\nabline(h=y)\ntrace une ligne horizontale sur l’ordonnée y\n\n\nabline(v=x)\ntrace une ligne verticale sur l’abscisse x\n\n\nrect(x1,y1,x2,y2)\ntrace un rectangle délimité à gauche par x1, à droite par x2,en bas par y1 et en haut par y2\n\n\npolygon(x,y)\ntrace un polygone reliant les points dont les coordonnées sont données par x et y\n\n\nlegend(x,y,legend)\najoute la légende au point de coordonnées (x,y) avec les symboles donnés par legend\n\n\ntitle()\najoute un titre et optionnellement un sous-titre\n\n\naxis(side, vect)\najoute un axe en bas (side=1), à gauche (2), en haut (3) ou à droite (4) ; vect (optionnel) indique les abscisses (ou ordonnées) où les graduations seront tracées\n\n\nbox()\najoute un cadre autour du graphe\n\n\n\n\n\n\n\n\n\n2.2.3 Exemples\n\nExemple 1Exemple 2Exemple 3\n\n\n\nx=seq(-10,10,l=50)\n# 2 graphiques\npar(mfrow=c(1,2))\n# premier graphique\nplot(x,sin(x),type=\"l\",col=1,main=\"sinus\")\nabline(v=0,col=\"blue\",lwd=5,lty=3)\nabline(h=sin(0.7),col=3)\ntext(-5,-0.5,\"texte\",font=3)\n# deuxieme graphique\nplot(x,cos(x),type=\"b\",col=3,xlab=\"Abscisses\")\npoints(x,cos(x),type=\"l\")\npoints(0,1,pch=\"o\",cex=3,col=\"blue\")\nlines(c(-5,5),c(0,0),lty=2,col=2)\n\n\n\n\n\n\n\ndata(iris)\npar(mfrow=c(2,2))\nplot(iris[,1],iris[,2],xlab=\"Sepal Length\",\nylab=\"Sepal Width\",main=\"Iris data\",\ncol=\"red\",type=\"p\")\npoints(iris[iris$Species==\"setosa\",1],iris[iris$Species==\"setosa\",2],col=\"green\",pch=20)\nhist(iris[,1],xlab=\"Sepal Length\",\nmain=\"Histogramme de la variable Sepal Length\")\nboxplot(iris[,1:4],las=2)\n\n\n\n\n\npairs(iris[,1:4])\n\n\n\n\n\npar(mfrow=c(2,2))\npie(table(iris[,5]))\npie(table(iris[,5]),clockwise=T)\nbarplot(table(iris[,5]))\nstripchart(iris,las=1)\n\n\n\n\n\n\n\nM=matrix(1:100,ncol=10)\nimage(M)\n\n\n\n\n\nx = seq(-10, 10, length= 30);y=x\nf = function(x,y){r=sqrt(x^2+y^2); 10 * sin(r)/r}\nz = outer(x, y, f)\nz[is.na(z)] = 1\npersp(x,y,z)\n\n\n\npersp(x, y, z, theta=30, phi=30,expand = 0.5,\n   col=\"lightblue\")\n\n\n\nimage(x,y,z)\n\n\n\ncontour(x,y,z)\n\n\n\nfilled.contour(x,y,z)\n\n\n\nimage(x,y,z)\ncontour(x,y,z,add=T)\n\n\n\n\n\n\n\n\n\n2.2.4 Exercices\n\nEnoncé 1Enoncé 2Enoncé 3Correction\n\n\n\nTracer la fonction arctangente entre \\(-10\\) et \\(10\\)\nAjouter les deux asymptotes en \\(-\\infty\\) et \\(+\\infty\\) en bleu\nAjouter les points sur la courbe pour \\(x=-\\pi\\), \\(0\\) et \\(\\pi\\) en vert\nAjouter la tangente en zéro en pointillés rouge\n\n\n\n\nCharger les données “airquality” disponible sous R à l’aide de data()\nUtiliser la commande pairs() pour visualiser variable contre variable\nCréer une fenêtre graphique contenant les boxplots des 4 premières variables, l’histogramme de la variable Ozone, le graphique en camembert de la variable Month, et le graphique représentant la variable Wind contre la variable Ozone avec une couleur par mois et une légende.\n\n\n\nSaurez-vous tracer la “tête à Toto” ?\n\n\n\nExercice 1 :\n\nx=seq(-10,10,0.01)\nplot(x,atan(x),type=\"l\",ylim=c(-pi/2-0.2,pi/2+0.2))\nabline(h=pi/2,col=\"blue\")\nabline(h=-pi/2,col=\"blue\")\npoints(c(-pi,0,pi),c(atan(-pi),0,atan(pi)),pch=20,col=\"green\")\nlines(c(-5,5),c(-5,5),lty=2,col=\"red\")\n\n\n\n\nExercice 2 :\n\n# Question 1\ndata(airquality)\nhead(airquality)\n\n  Ozone Solar.R Wind Temp Month Day\n1    41     190  7.4   67     5   1\n2    36     118  8.0   72     5   2\n3    12     149 12.6   74     5   3\n4    18     313 11.5   62     5   4\n5    NA      NA 14.3   56     5   5\n6    28      NA 14.9   66     5   6\n\n# Question 2\npairs(airquality)\n\n\n\n#Question 3\npar(mfrow=c(2,2))\nboxplot(airquality[,1:4])\npie(table(airquality[,\"Month\"]))\nplot(airquality$Ozone,airquality$Wind,col=airquality$Month,pch=20)\nlegend(x=\"topright\",legend=unique(airquality$Month),col=1:length(airquality$Month),pch=20)\n\n\n\n\nExercice 3 :\n\nplot(0,0,xlim=c(-15,15),ylim=c(-15,15),type=\"n\",axes=FALSE,xlab=\"\",ylab=\"\")\npoints(0,0,pch=\"+\",cex=4)\npoints(c(-4,4),c(5,5),pch=\"O\",cex=4)\nlines(c(-3,3),c(-5,-5),lwd=3)\nlines(c(-3,3),c(-6,-6),lwd=3)\nlines(10*sin(0:360*pi/180),10*cos(0:360*pi/180),lwd=5)\n# En option, le chapeau\nlines(c(-12,12),c(10,10),lwd=3)\nrect(-6,10,6,14,border=1,lwd=3,col=1)\n\n\n\n\n\n\n\n\n\n2.2.5 Exportation de graphiques\nDans l’environnement Windows, une première solution consiste à copier le graphique (menu Fichier &gt; Copier vers le presse-papier). Le graphique ainsi placé dans le presse-papier peut ensuite être collé dans le logiciel de son choix.\nPour sauvegarder le graphique dans un fichier, on utilisera dans le menu Fichier la rubrique Sauver sous. Plusieurs formats sont disponibles : vectoriel (métafichier), postscript, pdf, png, bmp, jpeg.\nUne autre façon de procéder est d’utiliser les fonctions associées à la sauvegarde de fichiers graphiques : bmp(), jpeg(), png(), pdf(), postscript().\nCette procédure est également utile en environnement Windows lorsque l’on souhaite sauver un graphique tracé lors du déroulement d’une fonction.\nOn peut également utiliser la commande dev.print(...) pour sauvegarder une figure en pdf ou eps."
  },
  {
    "objectID": "Part2-InitR.html#secProg",
    "href": "Part2-InitR.html#secProg",
    "title": "2  Initiation au langage et objets de R",
    "section": "2.3 Programmation",
    "text": "2.3 Programmation\nCette partie est consacrée à la création des fonctions, les instructions de contrôle, la syntaxe des itérations et la fonction apply() (et ses dérivées).\n\n2.3.1 Créer une fonction\nIl est possible sous R de construire ses propres fonctions. Il est conseillé d’écrire sa fonction dans un fichier nomfonction.R, puis dans la console, de charger la fonction grâce à la commande &gt;source(\"nomfonction.R\") et de l’utiliser. On peut également écrire directement la fonction dans la console. De manière générale, la définition d’une nouvelle fonction passe par l’expression suivante :\n\nnomfonction=function(arg1[=exp1],arg2[=exp2],...){\n    bloc d instructions\n    sortie = ...\n    return(sortie)\n}\n\nLes accolades signalent le début et la fin du code source de la fonction, les crochets indiquent le caractère facultatif des valeurs par défaut des arguments. L’objet sortie contient le ou les résultats retournés par la fonction, on peut en particulier utiliser une liste pour retourner plusieurs résultats.\n\nExemples\n\nExemple 1Exemple 2\n\n\n\nMaFonction=function(x){x+2}\nMaFonction\n\nfunction (x) \n{\n    x + 2\n}\n\nMaFonction(3)\n\n[1] 5\n\nx = MaFonction(4)\nx\n\n[1] 6\n\n\n\nFonction2=function(a,b=7){a+b}\nFonction2(2,b=3)\n\n[1] 5\n\nFonction2(5)\n\n[1] 12\n\n\n\n\nFonction retournant le périmètre et la surface d’un cercle à partir de son rayon :\n\nCalculsCercle=function(r){\n    p=2*pi*r\n    s=pi*r*r\n    resultats = list(perimetre=p,surface=s)\n    return(resultats)\n}\nres=CalculsCercle(3)\nres\n\n$perimetre\n[1] 18.84956\n\n$surface\n[1] 28.27433\n\nres$surf\n\n[1] 28.27433\n\n\n\n\n\n\n\nExercice\n\nEnoncéCorrection\n\n\n\nConstruire une fonction qui prend en argument deux réels x et y et qui retourne l’arrondi à 3 chiffres après la virgule de \\(x^2 + y\\). Vous pouvez vous aider de la fonction round().\nConstruire une fonction qui permet de calculer la densité de probabilité d’une loi normale de moyenne \\(m\\) et d’écart-type \\(s\\) au point \\(x\\).\n\n\n\nQuestion 1\n\narrond = function(x,y){\n  s=round((x^2)+y,3)\n  return(s)\n}\narrond(1.23456,9.8765)\n\n[1] 11.401\n\n\nQuestion 2\n\ndensitegauss = function(m,sigma,x){\n  f=(1/(sqrt(2*pi)*sigma)) * exp(-((x-m)^2)/(2*sigma^2))\n  return(f)\n}\ndensitegauss(1,2,1.2)\n\n[1] 0.1984763\n\ndnorm(1.2,1,2)\n\n[1] 0.1984763\n\n\n\n\n\n\n\n\n2.3.2 Structures de contrôle et itérations\n\n2.3.2.1 Instructions conditionnelles\nLa syntaxe if(condition){instructions} permet de calculer les instructions uniquement si la condition est vraie. Le code if(condition){ A }else{ B } calcule les instructions A si la condition est vraie et les instructions B sinon. On peut également utiliser ifelse.\nDans l’exemple suivant, les deux commandes sont équivalentes :\n\nif(x&gt;0){y=x*log(x)}else{ y=0}\ny=ifelse(x&gt;0,x*log(x),0)\n\n\n\nExercice\n\nEnoncéCorrection\n\n\n\nSoit \\(X\\) une variable aléatoire de loi de Poisson de paramètre \\(\\lambda=2\\). Écrire une fonction qui prend en argument un réel \\(x\\) et qui retourne la probabilité que \\(X\\) soit égal à \\(x\\).\n\n\nQuestion 1\n\nPoiss = function(x){\n  p=NULL\n  if ( (x&gt;=0) & (round(x)==x)){\n    p=exp(-2)*(2^x)/(factorial(x))\n  }else{\n    print(\"x n'est pas un entier\")\n  }\n  return(p)  \n}\n\nPoiss(3)\n\n[1] 0.180447\n\ndpois(3,2)\n\n[1] 0.180447\n\nPoiss(1.5)\n\n[1] \"x n'est pas un entier\"\n\n\nNULL\n\n\n\n\n\n\n\n2.3.2.2 Itérations\nOn utilise les boucles pour exécuter plusieurs fois une instruction ou un bloc d’instructions. Les trois types de boucle sont :\n\nla boucle for : for(var in seq){ commandes }\nla boucle while : while(cond){ commandes }\nla boucle repeat : repeat { commandes ; if (cond) break }\n\nDans une boucle for, le nombre d’itérations est fixe alors qu’il peut être infini pour les boucles while et repeat !\n\n\nExemples\nPour illustrer les trois types de boucle, on a codé de trois façons différentes la somme des éléments d’un vecteur x ce qui correspond à la fonction sum() de R.\n\nExemple for()Exemple while()Exemple repeat()\n\n\n\nsomme1=function(x){\nt = 0\nfor (i in 1:length(x))\n  t = t+x[i]\nreturn(t)\n}\n\nx = seq(1:10)\nsomme1(x)\n\n[1] 55\n\nsum(x)\n\n[1] 55\n\n\n\n\n\nsomme2=function(x){\nt = 0\ni = 1\nwhile (i&lt;=length(x)){\n  t = t+x[i]\n  i = i+1\n  }\nreturn(t)\n}\nx = seq(1:10)\nsomme2(x)\n\n[1] 55\n\nsum(x)\n\n[1] 55\n\n\n\n\n\nsomme3=function(x){\nt = 0\ni = 1\nrepeat{\n  t = t+x[i]\n  i = i+1\n  if (i&gt; length(x)) break\n  }\nreturn(t)\n}\n\nx = seq(1:10)\nsomme3(x)\n\n[1] 55\n\nsum(x)\n\n[1] 55\n\n\n\n\n\n\n\nExercice\n\nEnoncéCorrection\n\n\n\nÉcrire une fonction ma.variance qui calcule la variance empirique corrigée pour un vecteur \\(x = (x_1, . . . , x_n)\\). Comparer avec la fonction prédéfinie var().\nÉcrire une fonction qui calcule les \\(n\\) premiers termes de la suite de Fibonacci (\\(u_1=0, u_2=1, \\forall n&gt;2, u_n=u_{n-1}+u_{n-2}\\))\nEcrire une fonction qui prend en entrée un entier \\(x\\) et retourne sa factorielle \\(x!\\) avec une boucle for() puis avec une boucle while().\n\n\n\nQuestion 1\n\nma.variance=function(x){\n  v=0\n  m=0\n  n=length(x)\n  for (i in 1:n){\n    v=v+x[i]^2\n    m=m+x[i]\n  }\n  vv=(v - ((m^2)/n)) / (n-1)\n  return(vv)  \n}\n\nx = rnorm(10,0,2)\nma.variance(x)\n\n[1] 5.942672\n\nvar(x)\n\n[1] 5.942672\n\n\nQuestion 2\n\nfibo=function(n){\n    res=rep(0,n);res[1]=0;res[2]=1\n    for (i in 3:n){ \n        res[i]=res[i-1]+res[i-2]\n    }\n    return(res)\n}\nfibo(10)\n\n [1]  0  1  1  2  3  5  8 13 21 34\n\n\nQuestion 3\n\nfacto1 = function(x){\n  res=1\n  for (i in 1:x){\n    res=res*i\n  }\n  return(res)\n}\n\nfacto2 = function(x){\n  res = 1\n  while(x&gt;1){\n    res = res * x\n    x = x-1\n  }\nreturn(res)\n}\n\nfactorial(5)\n\n[1] 120\n\nfacto1(5)\n\n[1] 120\n\nfacto2(5)\n\n[1] 120\n\n\n\n\n\n\n\n\n2.3.3 apply() et ses variantes\nIl est recommandé d’éviter les boucles très chronophages. On peut utiliser pour cela la fonction apply() et ses variantes sapply(), lapply(), tapply() sur des vecteurs ou matrices.\nLa fonction apply() permet d’appliquer la même fonction FUN sur toutes les lignes (MARGIN=1) ou les colonnes (MARGIN=2) d’une matrice MAT : apply(MAT , MARGIN, FUN).\nLes fonctions lapply() et sapply() calculent la même fonction sur tous les éléments d’un vecteur ou d’une liste. La commande lapply(X,FUN, ARG.COMMUN) permet d’appliquer la fonction FUN à tous les éléments du vecteur ou de la liste X. Les valeurs de X sont affectées au premier argument de la fonction FUN. Si la fonction FUN a plusieurs paramètres d’entrée, ils sont spécifiés dans ARG.COMMUN. Cette fonction retourne le résultat sous la forme de listes. sapply() est une fonction similaire à lapply() mais le résultat est retourné sous forme de vecteurs, si possible.\nLa fonction tapply() applique une fonction FUN sur les sous-groupes d’un vecteur X définis par une variable de type factor GRP : tapply(X,GRP,FUN,...).\n\nExemples\n\ndata(iris)\nhead(iris)\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n4          4.6         3.1          1.5         0.2  setosa\n5          5.0         3.6          1.4         0.2  setosa\n6          5.4         3.9          1.7         0.4  setosa\n\napply(iris[,1:4],2,mean)\n\nSepal.Length  Sepal.Width Petal.Length  Petal.Width \n    5.843333     3.057333     3.758000     1.199333 \n\napply(iris[,1:4],1,mean)\n\n  [1] 2.550 2.375 2.350 2.350 2.550 2.850 2.425 2.525 2.225 2.400 2.700 2.500\n [13] 2.325 2.125 2.800 3.000 2.750 2.575 2.875 2.675 2.675 2.675 2.350 2.650\n [25] 2.575 2.450 2.600 2.600 2.550 2.425 2.425 2.675 2.725 2.825 2.425 2.400\n [37] 2.625 2.500 2.225 2.550 2.525 2.100 2.275 2.675 2.800 2.375 2.675 2.350\n [49] 2.675 2.475 4.075 3.900 4.100 3.275 3.850 3.575 3.975 2.900 3.850 3.300\n [61] 2.875 3.650 3.300 3.775 3.350 3.900 3.650 3.400 3.600 3.275 3.925 3.550\n [73] 3.800 3.700 3.725 3.850 3.950 4.100 3.725 3.200 3.200 3.150 3.400 3.850\n [85] 3.600 3.875 4.000 3.575 3.500 3.325 3.425 3.775 3.400 2.900 3.450 3.525\n [97] 3.525 3.675 2.925 3.475 4.525 3.875 4.525 4.150 4.375 4.825 3.400 4.575\n[109] 4.200 4.850 4.200 4.075 4.350 3.800 4.025 4.300 4.200 5.100 4.875 3.675\n[121] 4.525 3.825 4.800 3.925 4.450 4.550 3.900 3.950 4.225 4.400 4.550 5.025\n[133] 4.250 3.925 3.925 4.775 4.425 4.200 3.900 4.375 4.450 4.350 3.875 4.550\n[145] 4.550 4.300 3.925 4.175 4.325 3.950\n\nlapply(iris[,1:4],mean)\n\n$Sepal.Length\n[1] 5.843333\n\n$Sepal.Width\n[1] 3.057333\n\n$Petal.Length\n[1] 3.758\n\n$Petal.Width\n[1] 1.199333\n\nsapply(iris[,1:4],mean)\n\nSepal.Length  Sepal.Width Petal.Length  Petal.Width \n    5.843333     3.057333     3.758000     1.199333 \n\ntapply(iris[,1],iris[,5],mean)\n\n    setosa versicolor  virginica \n     5.006      5.936      6.588 \n\n\n\n\nExercices\n\nEnoncé 1Enoncé 2Correction\n\n\nSoit la fonction suivante :\n\nExo1=function(M){\n  res=rep(0,5)\n  for (i in 1:5){\n    tmp=0\n    for (j in 1:4) {tmp = tmp + M[i,j]}\n    res[i]=tmp\n  }\nreturn(res)\n}\n\nM=matrix(1:20,nrow=5,ncol=4)\nExo1(M)\n\nProposer une fonction équivalente sans aucune boucle.\n\n\n\nRéaliser une liste de \\(100\\) réalisations d’une loi normale \\(\\mathcal{N}(m,1)\\) pour \\(m=-2\\), \\(0\\) et \\(2\\) respectivement en utilisant lapply() et rnorm().\nCréer un vecteur contenant la moyenne de chaque échantillon de la question 1.\n\n\n\nExercice 1 :\n\nM=matrix(1:20,nrow=5,ncol=4)\napply(M,1,sum)\n\n[1] 34 38 42 46 50\n\n\nExercice 2 :\n\nx=lapply(c(-2,0,2),function(x){rnorm(1000,mean=x,sd=1)})\nsapply(x, mean)\n\n[1] -2.01933642 -0.06109927  2.00969092"
  },
  {
    "objectID": "Part2-InitR.html#entrée-sortie",
    "href": "Part2-InitR.html#entrée-sortie",
    "title": "2  Initiation au langage et objets de R",
    "section": "2.4 Entrée / Sortie",
    "text": "2.4 Entrée / Sortie\n\n2.4.1 Importation d’un jeu de données\nPour importer un tableau de données contenu dans un fichier texte en un data.frame, on utilise la fonction read.table(). Par exemple, pour un fichier nommé “Tableau.txt”, on utilisera la commande Tab1 = read.table(\"Tableau.txt\") qui crée un data.frame Tab1. Si le fichier n’est pas placé dans le répertoire courant, on pourra spécifier le chemin d’accès de ce dernier directement dans la commande read.table(). Cette dernière admet les options principales suivantes :\n\nheader : indique si la première ligne contient des noms de variables. Par défaut, la valeur de cette option est FALSE.\nsep : précise le séparateur de champ dans le fichier entre guillemets (” ” par défaut).\ndec : le caractère utilisé pour les décimales (“.” par défaut).\nrow.names : indique par l’intermédiaire d’un vecteur de mode caractère le nom des lignes (par défaut : 1; 2; 3; : : : ).\ncol.names : idem pour les colonnes.\nna.strings : précise la valeur des données manquantes. Par défaut, la valeur de cette option est “NA”.\nnrows : nombre maximum de lignes à lire.\nskip : nombre de lignes à sauter avant de commencer à lire des données. Cette option est utile quand le fichier texte contient par exemple un préambule.\nblank.lines.skip : si “TRUE”, ignore les lignes blanches.\ncomment.char : précise le caractère utilisé pour faire des commentaires. Toutes les lignes commençant par ce caractère ne seront pas prises en compte.\n\nCette liste d’options n’est pas exhaustive (cf l’aide en ligne help(read.table)) mais permet déjà d’analyser un nombre conséquent de fichiers textes. Les fonctions read.csv() et read.csv2() en sont des cas particuliers, c’est-à-dire avec des options spécifiques (caractère séparateur, marque décimale) adaptées aux fichiers lus / écrits par des tableurs en format .csv .\n\nExercice\n\nEnoncéCorrection\n\n\nExecutez les commandes suivantes pour préparer l’exercice.\n\ndata(iris)\ndir.create(\"DataAux\")\nwrite.table(iris,file=\"DataAux/iris1.txt\",sep=\";\",row.names=F,col.names=T)\nrownames(iris)=paste(\"indiv\",1:nrow(iris),sep=\"-\")\nwrite.table(iris,file=\"DataAux/iris2.csv\",row.names=T,col.names=F)\nwrite.table(iris,file=\"DataAux/iris3.txt\",quote=FALSE, dec=\",\",sep=\"*\")\n\nChargez à l’aide de la fonction read.table() les données iris1.txt, iris2.csv et iris3.txt disponibles dans le dossier DataAux.\n\n\n\niris1 = read.table(\"DataAux/iris1.txt\",header=T,sep=\";\")\nhead(iris1)\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n4          4.6         3.1          1.5         0.2  setosa\n5          5.0         3.6          1.4         0.2  setosa\n6          5.4         3.9          1.7         0.4  setosa\n\niris2= read.table(\"DataAux/iris2.csv\",header=F,row.names=1)\nhead(iris2)\n\n         V2  V3  V4  V5     V6\nindiv-1 5.1 3.5 1.4 0.2 setosa\nindiv-2 4.9 3.0 1.4 0.2 setosa\nindiv-3 4.7 3.2 1.3 0.2 setosa\nindiv-4 4.6 3.1 1.5 0.2 setosa\nindiv-5 5.0 3.6 1.4 0.2 setosa\nindiv-6 5.4 3.9 1.7 0.4 setosa\n\niris3=read.table(\"DataAux/iris3.txt\",header=T,row.names=1,sep=\"*\",dec=\",\")\nhead(iris3)\n\n        Sepal.Length Sepal.Width Petal.Length Petal.Width Species\nindiv-1          5.1         3.5          1.4         0.2  setosa\nindiv-2          4.9         3.0          1.4         0.2  setosa\nindiv-3          4.7         3.2          1.3         0.2  setosa\nindiv-4          4.6         3.1          1.5         0.2  setosa\nindiv-5          5.0         3.6          1.4         0.2  setosa\nindiv-6          5.4         3.9          1.7         0.4  setosa\n\n\n\n\n\n\n\n\n2.4.2 Exportation\n\n2.4.2.1 Exportation en fichier texte\nSi maintenant on désire sauvegarder un objet R dans un fichier texte, on peut utiliser la commande write.table(). Les principales options de cette fonction sont :\n\nfile : nom du fichier dans lequel écrire (vérifier le répertoire courant)\nappend : prend une valeur logique. Si TRUE, R ajoute les données dans le fichier concerné sans effacer les précédentes. La valeur par défaut est FALSE.\nsep : précise le séparateur à utiliser.\neol : caractère de fin de ligne. Par défaut prend la valeur “n” (retour chariot)\nna : caractère à utiliser pour les données manquantes.\ndec : précise le caractère à utiliser pour les décimales.\n\n\n\n2.4.2.2 Sauvegarde .RData\nR permet d’enregistrer des objets entiers, en conservant à la fois les données contenues dans les objets et les structures des objets.\nLa fonction save.image() peut être utilisée à tout moment pour enregistrer une image de session, c’est à dire l’ensemble des objets dans l’environnement de travail d’une session R. La sauvegarde d’une image de la session vous est également proposée lors de la fermeture de R.\n\nsave.image(file = \"eximage.RData\")\n\nLa fonction save() permet d’enregistrer spécifiquement un ou des objets dans un fichier de format .RData. Ce fichier peut être à tout moment rechargé sous R avec la fonction load(). Voici un exemple :\n\nx &lt;- stats::runif(20)\ny &lt;- list(a = 1, b = TRUE, c = \"oops\")\nsave(x, y, file = \"xy.RData\")\nload(\"xy.RData\")\n\nOn peut aussi enregistrer un seul objet, sans inclure le nom de l’objet, à l’aide de la fonction saveRDS(). L’objet, sauvegardé au format .rds peut être rechargé avec la fonction readRDS().\n\n\nPour plus de détails sur les importations et exportations, se référer au document R Data Import/Export disponible sur le CRAN."
  },
  {
    "objectID": "Part3-StatR.html#lois-usuelles-de-probabilité",
    "href": "Part3-StatR.html#lois-usuelles-de-probabilité",
    "title": "3  Statistique avec R",
    "section": "3.1 Lois usuelles de probabilité",
    "text": "3.1 Lois usuelles de probabilité\n\nDe nombreuses distributions de probabilité sont disponibles sous R. En voici une liste non exhaustive :\n\n\n\nTable des lois usuelles sous R\n\n\nLoi\nNomR\n\n\n\n\nBeta\nbeta\n\n\nBinomiale\nbinom\n\n\nCauchy\ncauchy\n\n\nKhi-Deux\nchisq\n\n\nExponentielle\nexp\n\n\nFisher\nf\n\n\nGamma\ngamma\n\n\nGéométrique\ngeom\n\n\nHypergéométrique\nhyper\n\n\nLog-Normale\nlnorm\n\n\nLogistique\nlogis\n\n\nNormale\nnorm\n\n\nPoisson\npois\n\n\nStudent\nt\n\n\nUniforme\nunif\n\n\nWeibull\nweibull\n\n\n\n\n\nPour chaque distribution, quatre commandes préfixées par une des lettres d, p, q, r et suivi du nom de la distribution (nomdist) sont disponibles :\n- dnomdist : fonction de densité \\(f_X(.)\\) pour une loi continue ou fonction de probabilité \\(\\mathbb{P}(X = k)\\) pour une loi discrète\n- pnomdist : fonction de répartition \\(F_X(.) = \\mathbb{P}(X\\leq .)\\)\n- qnomdist : quantiles\n- rnomdist : génère des réalisations aléatoires indépendantes de la distribution nomdist.\nVous pouvez retrouver ces informations dans l’aide de R ?Distributions.\n\nExempleExercice 1Exercice 2Correction\n\n\nSoit \\(X\\) une variable aléatoire de loi \\(\\mathcal{N}(0,1)\\), alors\n\ndnorm(10) évalue la valeur de la fonction densité en \\(x=10\\) i.e \\(f_X(10)\\)\npnorm(0) évalue la valeur de la fonction de répartition en \\(x=0\\) i.e \\(F_X(0)=\\mathbb{P}(X\\leq 0)=\\frac 1 2\\)\nqnorm(0.95) évalue le quantile à l’ordre \\(0.95\\) de la loi normale \\(\\mathcal{N}(0,1)\\)\nrnorm(10) génère un un échantillon observé de taille \\(10\\) pour la loi \\(\\mathcal{N}(0,1)\\)\n\n\n\n\nSimuler un échantillon de taille 1000 suivant une loi normale \\(\\mathcal{N}(0,1)\\).\n\nSur un même graphique, superposer la répartition empirique (histogramme) et la densité de la loi \\(\\mathcal{N}(0,1)\\).\n\nSur un même graphique, superposer la fonction de répartition empirique et la fonction de répartition de la loi \\(\\mathcal{N}(0,1)\\).\nReprendre les questions précédentes avec d’autres lois de votre choix.\n\n\n\nIllustration du Théorème de la limite centrale (TCL)\n\nGénérer \\(N=10000\\) échantillons de taille \\(n\\) (pour la loi de votre choix), pour différentes valeurs de \\(n\\).\n\nA chaque fois, on prendra soin de faire apparaître sur un même graphique la répartition des \\(N\\) moyennes empiriques (sous forme d’un histogramme) ainsi que la densité de la variable gaussienne limite associée.\n\n\n\nExercice 1 :\n\nQuestion 1 :\n\n\n# Question 1\nEch=rnorm(1000,0,1)\n\n\nQuestion 2 :\n\n\nggplot()plot()\n\n\n\nggplot(data.frame(Ech=Ech), aes(x=Ech)) + \n  geom_histogram(aes(y = ..density..),bins=50,fill=\"white\",colour=\"black\") + \n  stat_function(fun = dnorm, aes(x = Ech),colour=\"red\") \n\n\n\n\n\n\n\nhist(Ech,breaks=50,freq=F)\npoints(seq(-4,4,0.01),dnorm(seq(-4,4,0.01)),type=\"l\",col=\"red\")\n\n\n\n\n\n\n\n\nQuestion 3 :\n\n\nggplot()plot()\n\n\n\nggplot(data.frame(Ech=Ech), aes(x=Ech)) + \n  stat_ecdf(geom = \"step\")+ \n  stat_function(fun = pnorm, aes(x = Ech),colour=\"red\") \n\n\n\n\n\n\n\nplot(ecdf(Ech))\npoints(seq(-4,4,0.01),pnorm(seq(-4,4,0.01)),col=\"red\",type='l')\n\n\n\n\n\n\n\nExercice 2 :\nEnoncé du TLC : Soit \\(X_1,\\ldots,X_n\\) i.i.d d’espérance \\(\\mathbb{E}[X_1]&lt;+\\infty\\) et variance \\(Var(X_1)&lt;+\\infty\\). Alors \\(\\sqrt{n} \\frac{\\bar X_n - \\mathbb{E}[X_1]}{\\sqrt{Var(X_1)}} \\underset{n\\rightarrow +\\infty}{\\stackrel{\\mathcal{L}}{\\rightarrow}} \\mathcal{N}(0,1).\\)\n\n# Illustration ici avec la loi de Bernoulli\np=0.4\nn=1000\nN=10000\nX=matrix(rbinom(n*N,size = 1,prob=p),nrow=N, ncol=n)\nXbar=apply(X,1,mean)\nV=sqrt(n)*(Xbar-p)/sqrt(p*(1-p))\n\n\nggplot()plot()\n\n\n\nggplot(data.frame(Ech=V), aes(x=Ech)) + \n  geom_histogram(aes(y = ..density..),bins = 30,fill=\"white\",colour=\"black\") + \n  stat_function(fun = dnorm, aes(x = Ech),colour=\"red\") \n\n\n\n\n\n\n\nhist(V,breaks=30,freq=F)\npoints(seq(-3,3,0.01),dnorm(seq(-3,3,0.01)),col=\"red\",type=\"l\")"
  },
  {
    "objectID": "Part3-StatR.html#statistiques-descriptives",
    "href": "Part3-StatR.html#statistiques-descriptives",
    "title": "3  Statistique avec R",
    "section": "3.2 Statistiques descriptives",
    "text": "3.2 Statistiques descriptives\nOn va illustrer toute cette section à l’aide du jeu de données wine disponible dans Data/wine.txt. Ce jeu de données comprend des mesures physico-chimiques réalisées sur un échantillon de \\(600\\) vins (rouges et blancs) du Portugal. Ces mesures sont complétées par une évaluation sensorielle de la qualité par un ensemble d’experts. Chaque vin est décrit par les variables suivantes :\n\nQualite : son évaluation sensorielle par les experts (“bad”,“medium”,“good”),\nType : son type (1 pour un vin rouge, 0 pour un vin blanc),\nAcidVol : la teneur en acide volatile (en g/dm3 d’acide acétique),\nAcidCitr : la teneur en acide citrique (en g/dm3),\nSO2lbr : le dosage du dioxyde de soufre libre (en mg/dm3),\nSO2tot : le dosage du dioxyde de soufre total (en mg/dm3),\nDensite : la densité (en g/cm3),\nAlcool : le degré d’alcool (en % Vol.).\n\nDans un premier temps, commencez par charger le jeu de données avec la commande suivante Data = read.table(\"Data/wine.txt\",header=T).\nVoici les premières lignes du jeu de données :\n\nhead(Data)\n\n     Qualite Type AcidVol AcidCitr SO2lbr SO2tot Densite Alcool\n1352  medium    1    0.62     0.01      8     46 0.99332   11.8\n5493  medium    0    0.34     0.10     17     63 0.99370    9.2\n5153  medium    0    0.22     0.22     39    110 0.99855    9.0\n5308  medium    0    0.35     0.46     61    183 0.99786    9.0\n3866  medium    0    0.42     0.32     20    167 0.99479   10.6\n694   medium    1    0.48     0.32     21    122 0.99840    9.4\n\n\nLe jeu de données est donc maintenant stocké dans l’objet Data de type data.frame (&gt;class(Data) data.frame).\n\n3.2.1 Contenu du jeu de données\nOn peut commencer par regarder les dimensions du jeu de données à étudier à l’aide des commandes dim(), nrow()et ncol() :\n\ndim(Data)\n\n[1] 600   8\n\nnrow(Data)\n\n[1] 600\n\nncol(Data)\n\n[1] 8\n\n\nAinsi le jeu de données contient 600 individus (correspondant aux 600 lignes) décrits par 8 variables (correspondant aux 8 colonnes). Remarquons que l’on peut obtenir les noms des variables grâce à la commande names(Data). Plus largement, on peut utiliser la commande attributes() :\n\nattributes(Data)\n\n$names\n[1] \"Qualite\"  \"Type\"     \"AcidVol\"  \"AcidCitr\" \"SO2lbr\"   \"SO2tot\"   \"Densite\" \n[8] \"Alcool\"  \n\n$class\n[1] \"data.frame\"\n\n$row.names\n  [1] \"1352\" \"5493\" \"5153\" \"5308\" \"3866\" \"694\"  \"5085\" \"2280\" \"5231\" \"4388\"\n [11] \"4172\" \"4763\" \"4001\" \"3244\" \"4663\" \"3256\" \"3444\" \"3867\" \"3161\" \"6420\"\n [21] \"1590\" \"2155\" \"2258\" \"209\"  \"4560\" \"1981\" \"2166\" \"5430\" \"6496\" \"346\" \n [31] \"1288\" \"3615\" \"1837\" \"5637\" \"2520\" \"3046\" \"2983\" \"840\"  \"3185\" \"4690\"\n [41] \"6347\" \"728\"  \"240\"  \"6318\" \"2501\" \"3003\" \"4537\" \"4799\" \"141\"  \"3664\"\n [51] \"5167\" \"5291\" \"3383\" \"2712\" \"449\"  \"214\"  \"3216\" \"4917\" \"5005\" \"3501\"\n [61] \"1291\" \"3137\" \"998\"  \"1350\" \"6336\" \"492\"  \"3901\" \"4878\" \"5343\" \"5096\"\n [71] \"4516\" \"1118\" \"2680\" \"452\"  \"3937\" \"776\"  \"528\"  \"3445\" \"203\"  \"1175\"\n [81] \"5796\" \"2334\" \"3564\" \"1921\" \"4995\" \"1070\" \"5286\" \"4421\" \"5630\" \"273\" \n [91] \"896\"  \"5267\" \"742\"  \"956\"  \"4435\" \"414\"  \"2737\" \"1496\" \"455\"  \"3970\"\n[101] \"286\"  \"1535\" \"3144\" \"5473\" \"6308\" \"5051\" \"3502\" \"4286\" \"1408\" \"2581\"\n[111] \"6225\" \"4614\" \"3065\" \"54\"   \"6300\" \"2050\" \"5574\" \"3368\" \"2332\" \"4225\"\n[121] \"5508\" \"2830\" \"5669\" \"6141\" \"6395\" \"5337\" \"878\"  \"4190\" \"5778\" \"3316\"\n[131] \"5832\" \"5672\" \"1786\" \"2654\" \"1199\" \"5997\" \"1347\" \"4785\" \"5400\" \"2157\"\n[141] \"3552\" \"788\"  \"2624\" \"1912\" \"499\"  \"2522\" \"6456\" \"4425\" \"618\"  \"1139\"\n[151] \"5815\" \"1191\" \"1348\" \"771\"  \"5530\" \"858\"  \"4070\" \"5460\" \"4236\" \"5919\"\n[161] \"6340\" \"5170\" \"3266\" \"3696\" \"6310\" \"6269\" \"3258\" \"6313\" \"362\"  \"2374\"\n[171] \"4507\" \"1575\" \"3468\" \"5729\" \"6469\" \"510\"  \"6107\" \"1178\" \"4973\" \"4120\"\n[181] \"5295\" \"2076\" \"3989\" \"4518\" \"3184\" \"1198\" \"1847\" \"2285\" \"6022\" \"6087\"\n[191] \"113\"  \"5667\" \"3317\" \"933\"  \"4658\" \"1923\" \"4026\" \"2244\" \"226\"  \"1254\"\n[201] \"747\"  \"2809\" \"1137\" \"2067\" \"2455\" \"6163\" \"3977\" \"50\"   \"3418\" \"5477\"\n[211] \"2389\" \"6243\" \"65\"   \"3678\" \"3117\" \"4327\" \"4206\" \"1169\" \"4188\" \"5392\"\n[221] \"1477\" \"3063\" \"6342\" \"4634\" \"3862\" \"1497\" \"193\"  \"2273\" \"3074\" \"583\" \n[231] \"6169\" \"3865\" \"5812\" \"2658\" \"4152\" \"753\"  \"4000\" \"5504\" \"1861\" \"6068\"\n[241] \"4950\" \"4654\" \"1511\" \"1001\" \"2386\" \"1242\" \"2045\" \"2743\" \"1413\" \"2060\"\n[251] \"5915\" \"469\"  \"5454\" \"4119\" \"397\"  \"1278\" \"2307\" \"1279\" \"4528\" \"761\" \n[261] \"3747\" \"199\"  \"802\"  \"4150\" \"271\"  \"5070\" \"6303\" \"146\"  \"3768\" \"4665\"\n[271] \"2703\" \"5349\" \"1693\" \"1640\" \"5547\" \"354\"  \"4161\" \"3230\" \"1319\" \"3832\"\n[281] \"2894\" \"3282\" \"5782\" \"570\"  \"5111\" \"6433\" \"229\"  \"5419\" \"2174\" \"1749\"\n[291] \"4782\" \"5163\" \"6059\" \"4836\" \"5635\" \"6054\" \"6437\" \"3347\" \"684\"  \"48\"  \n[301] \"2117\" \"1224\" \"96\"   \"4131\" \"2726\" \"2511\" \"6262\" \"3086\" \"1253\" \"4549\"\n[311] \"723\"  \"5287\" \"3739\" \"1658\" \"76\"   \"1604\" \"149\"  \"554\"  \"349\"  \"639\" \n[321] \"416\"  \"2966\" \"378\"  \"475\"  \"1212\" \"5670\" \"15\"   \"4986\" \"324\"  \"3657\"\n[331] \"5571\" \"881\"  \"322\"  \"1998\" \"3795\" \"5064\" \"232\"  \"5447\" \"2232\" \"5307\"\n[341] \"3578\" \"4645\" \"6277\" \"6483\" \"1028\" \"5649\" \"1493\" \"52\"   \"4329\" \"5765\"\n[351] \"4927\" \"4871\" \"5099\" \"419\"  \"2019\" \"3490\" \"5412\" \"4310\" \"2156\" \"4040\"\n[361] \"4791\" \"6205\" \"1295\" \"4177\" \"2216\" \"6355\" \"4493\" \"4428\" \"3089\" \"2142\"\n[371] \"4354\" \"5650\" \"2801\" \"2977\" \"919\"  \"1951\" \"3641\" \"5697\" \"6452\" \"3271\"\n[381] \"4515\" \"3665\" \"4167\" \"6008\" \"6094\" \"605\"  \"5608\" \"2942\" \"2360\" \"4579\"\n[391] \"4805\" \"239\"  \"612\"  \"4937\" \"3692\" \"4287\" \"2203\" \"1547\" \"5444\" \"872\" \n[401] \"4513\" \"6280\" \"5050\" \"2226\" \"5135\" \"5278\" \"2570\" \"4509\" \"2732\" \"1820\"\n[411] \"5495\" \"1882\" \"789\"  \"4290\" \"1249\" \"3306\" \"5468\" \"2342\" \"2217\" \"1252\"\n[421] \"1828\" \"832\"  \"4529\" \"2750\" \"5511\" \"4111\" \"2200\" \"695\"  \"611\"  \"1916\"\n[431] \"1646\" \"1774\" \"1977\" \"5298\" \"1007\" \"3956\" \"5659\" \"6\"    \"1365\" \"619\" \n[441] \"3131\" \"2941\" \"2027\" \"3838\" \"6039\" \"5624\" \"5323\" \"2730\" \"1783\" \"1579\"\n[451] \"3397\" \"3685\" \"5180\" \"1741\" \"5219\" \"5103\" \"997\"  \"1451\" \"2102\" \"309\" \n[461] \"3508\" \"4429\" \"2320\" \"4943\" \"1236\" \"5285\" \"1622\" \"2865\" \"254\"  \"581\" \n[471] \"4635\" \"198\"  \"5257\" \"5006\" \"2363\" \"922\"  \"399\"  \"3948\" \"2198\" \"5393\"\n[481] \"4609\" \"5299\" \"2598\" \"1214\" \"5875\" \"3626\" \"4087\" \"783\"  \"1482\" \"290\" \n[491] \"5956\" \"3011\" \"2293\" \"6176\" \"3871\" \"5478\" \"1123\" \"319\"  \"2469\" \"4151\"\n[501] \"2395\" \"4073\" \"2072\" \"1762\" \"1775\" \"3325\" \"1560\" \"3769\" \"5755\" \"4011\"\n[511] \"6389\" \"4958\" \"3523\" \"1452\" \"4576\" \"5182\" \"1179\" \"1059\" \"6467\" \"369\" \n[521] \"5795\" \"1836\" \"1684\" \"1737\" \"988\"  \"5853\" \"1201\" \"866\"  \"110\"  \"775\" \n[531] \"5303\" \"1938\" \"1283\" \"5636\" \"1474\" \"3236\" \"2262\" \"2881\" \"892\"  \"2032\"\n[541] \"129\"  \"6375\" \"1044\" \"540\"  \"3219\" \"3183\" \"1895\" \"2631\" \"1354\" \"655\" \n[551] \"4963\" \"3040\" \"4729\" \"6286\" \"5823\" \"4224\" \"729\"  \"719\"  \"5217\" \"3569\"\n[561] \"1447\" \"1394\" \"4794\" \"1664\" \"501\"  \"3668\" \"3098\" \"1080\" \"2266\" \"186\" \n[571] \"5841\" \"3375\" \"1111\" \"430\"  \"677\"  \"3973\" \"6471\" \"1021\" \"3674\" \"6203\"\n[581] \"2762\" \"572\"  \"5960\" \"970\"  \"460\"  \"4630\" \"5655\" \"5365\" \"2020\" \"3275\"\n[591] \"5150\" \"3265\" \"3328\" \"3925\" \"1265\" \"768\"  \"670\"  \"1156\" \"2275\" \"974\" \n\n\nLa commande str() affiche quand à elle d’autres informations concernant les données. En particulier, on retrouve le type (data.frame) et la dimension (nombres d’observations et de variables) des données. En outre, pour chaque variable, on peut lire son nom, son format (entier, numérique, caractère) ainsi que ses premières valeurs.\n\nstr(Data)\n\n'data.frame':   600 obs. of  8 variables:\n $ Qualite : chr  \"medium\" \"medium\" \"medium\" \"medium\" ...\n $ Type    : int  1 0 0 0 0 1 0 0 0 0 ...\n $ AcidVol : num  0.62 0.34 0.22 0.35 0.42 0.48 0.21 0.28 0.3 0.4 ...\n $ AcidCitr: num  0.01 0.1 0.22 0.46 0.32 0.32 0.32 0.14 0.25 0.42 ...\n $ SO2lbr  : num  8 17 39 61 20 21 39 64 21 41 ...\n $ SO2tot  : int  46 63 110 183 167 122 113 159 124 176 ...\n $ Densite : num  0.993 0.994 0.999 0.998 0.995 ...\n $ Alcool  : num  11.8 9.2 9 9 10.6 9.4 10.2 10 10.8 9.4 ...\n\n\nOn voit ici que les variables sont de différentes natures :\n\nLes variables Qualite et Type sont des variables qualitatives\nLes autres variables sont quantitatives\n\nAttention à bien préciser à R les variables qui doivent être considérées comme qualitatives. Ici, on change donc la nature des variables Qualite et Type :\n\nData$Qualite=as.factor(Data$Qualite)\nData$Type=factor(Data$Type,labels=c(\"blanc\",\"rouge\"))\nhead(Data)\n\n     Qualite  Type AcidVol AcidCitr SO2lbr SO2tot Densite Alcool\n1352  medium rouge    0.62     0.01      8     46 0.99332   11.8\n5493  medium blanc    0.34     0.10     17     63 0.99370    9.2\n5153  medium blanc    0.22     0.22     39    110 0.99855    9.0\n5308  medium blanc    0.35     0.46     61    183 0.99786    9.0\n3866  medium blanc    0.42     0.32     20    167 0.99479   10.6\n694   medium rouge    0.48     0.32     21    122 0.99840    9.4\n\n\nOn peut obtenir un résumé rapide du jeu de données à l’aide de la fonction summary()\n\nsummary(Data)\n\n   Qualite       Type        AcidVol          AcidCitr          SO2lbr      \n bad   : 19   blanc:425   Min.   :0.1000   Min.   :0.0000   Min.   :  2.00  \n good  :110   rouge:175   1st Qu.:0.2400   1st Qu.:0.2400   1st Qu.: 15.75  \n medium:471               Median :0.3000   Median :0.3000   Median : 27.00  \n                          Mean   :0.3512   Mean   :0.3141   Mean   : 29.41  \n                          3rd Qu.:0.4300   3rd Qu.:0.3900   3rd Qu.: 41.00  \n                          Max.   :1.0400   Max.   :1.0000   Max.   :112.00  \n     SO2tot         Densite           Alcool     \n Min.   :  7.0   Min.   :0.9875   Min.   : 8.00  \n 1st Qu.: 68.0   1st Qu.:0.9925   1st Qu.: 9.50  \n Median :114.5   Median :0.9949   Median :10.40  \n Mean   :111.2   Mean   :0.9947   Mean   :10.49  \n 3rd Qu.:154.0   3rd Qu.:0.9970   3rd Qu.:11.30  \n Max.   :278.0   Max.   :1.0030   Max.   :14.00  \n\n\n\n\n3.2.2 Statistiques descriptives unidimensionnelles\n\n3.2.2.1 Variable qualitative\nOn considère ici une variable qualitative \\(X\\) dont on observe \\(n\\) réalisations \\(\\underline{x}=(x_1,x_2,\\ldots,x_n)\\). Cette variable prend \\(K\\) modalités \\(m_1,\\ldots,m_K\\). Si les modalités n’ont pas d’ordre naturel, on parle de variable qualitative nominale (ex. Type), sinon c’est une variable qualitative ordinale (ex. Qualite).\nLa variable Type contient \\(K=\\) 2 modalités qui sont blanc, rouge.\n\nlevels(Data$Type)\n\n[1] \"blanc\" \"rouge\"\n\n\nOn récupère l’effectif \\(n_k=\\underset{i=1}{\\stackrel{n}{\\sum}} \\mathbb{1}_{x_i=m_k}\\) pour chaque modalité \\(m_k\\) avec summary()ou table().\n\nsummary(Data$Type)\n\nblanc rouge \n  425   175 \n\nEffType = as.vector(table(Data$Type))\nEffType\n\n[1] 425 175\n\n\nOn utilise aussi les fréquences \\(f_k=\\frac{n_k}{n}\\) donc \\(\\underset{k=1}{\\stackrel{K}{\\sum}}f_k=1\\).\n\nFreq = EffType/length(Data$Type)\n\n\n\n\nDescription de la variable Type\n\n\nmodalite\nEff\nFreq\n\n\n\n\nblanc\n425\n0.708\n\n\nrouge\n175\n0.292\n\n\n\n\n\nPour une variable qualitative ordinale, on utilise également les effectifs cumulés \\(N_k=\\underset{\\ell=1}{\\stackrel{k}{\\sum}} n_\\ell\\) et les fréquences cumulées \\(F_k=\\underset{\\ell=1}{\\stackrel{k}{\\sum}} f_\\ell\\).\n\nVisualisation\n\nggplotplot\n\n\nPour la variable Type :\n\ng1 =ggplot(Data) + \n  geom_bar(aes(x = Type))+\n  ggtitle(\"Effectifs\")\ng2 =ggplot(Data) + \n  geom_bar(aes(x = Type, y = ..prop.., group = 1))+\n  ggtitle(\"Frequences\")\ndf = data.frame(\n  type = levels(Data$Type),\n  value = as.vector(Freq)\n  )\ng3 = ggplot(df, aes(x=\"\", y=value, fill=type))+\ngeom_bar(width = 1, stat = \"identity\")\ng4 = g3 + coord_polar(\"y\", start=0)\n\ngrid.arrange(g1,g2,g3,g4,nrow=2)\n\n\n\n\nPour la variable Qualité :\n\nlibrary(tidyverse)\nData$Qualite_rec &lt;- fct_relevel(Data$Qualite,\"bad\",\"medium\",\"good\")\ndf &lt;- data.frame( \n   Qualite = levels(Data$Qualite_rec), \n   value = table(Data$Qualite_rec), \n   valuecumul=100*cumsum(prop.table(table(Data$Qualite_rec))) \n   ) \ndf$Qualite&lt;-fct_relevel(df$Qualite,\"bad\",\"medium\",\"good\")\ndf&lt;-df%&gt;%mutate(freq=value.Freq/nrow(Data))\ng1 &lt;- ggplot(Data) + \n  geom_bar(aes(x = Qualite_rec))+\n  ggtitle(\"Effectifs\")\ng2 &lt;- ggplot(Data) +  \n   geom_bar(aes(x = Qualite_rec, y = ..prop.., group = 1))+ \n   ggtitle(\"Frequences\") \ng3 &lt;- ggplot(df, aes(x = Qualite, y = valuecumul)) +  \n   geom_bar(stat = \"identity\")+ \n   ggtitle(\"Fréquences cumulées\") \n\ng4 &lt;- ggplot(df, aes(x = \"\", y = freq, fill = Qualite)) + geom_bar(width = 1, stat = \"identity\")+ coord_polar(\"y\", start = 0)\n \n \ngrid.arrange(g1,g2,g3,g4,ncol=2) \n\n\n\n\n\n\nPour une variable qualitative, on utilise la représentation par camembert (pie) ou diagramme en bâton (barplot)\n\npar(mfrow=c(1,3))\npie(table(Data$Type))\nbarplot(table(Data$Type),main=\"Effectifs\")\nbarplot(table(Data$Type)/nrow(Data),main=\"Frequences\")\n\n\n\n\nPour une variable qualitative ordinale, on peut également tracer les fréquences cumulées :\n\nlibrary(tidyverse)\nData$Qualite_rec &lt;- fct_relevel(Data$Qualite,\"bad\",\"medium\",\"good\")\npar(mfrow=c(1,3))\npie(table(Data$Qualite_rec))\nbarplot(table(Data$Qualite_rec)/nrow(Data),main=\"Frequences\")\nbarplot(cumsum(table(Data$Qualite_rec))/nrow(Data),main=\"Freq. cumulées\")\n\n\n\n\n\nData&lt;-Data[,-9]\n\n\n\n\n\n\n\n\n\n3.2.2.2 Variable quantitative\nNous allons ici nous intéresser à l’étude d’une variable quantitative \\(X\\) dont on a \\(n\\) observations \\(\\underline{x}=(x_1,\\ldots,x_n)\\). On va illustrer cette section avec la variable Alcool.\n\n\nIndices statistiques\nNous rappelons les principaux indicateurs statistiques que l’on peut évaluer pour une série de mesures \\(\\underline{x}\\): la moyenne, la médiane, la variance, l’écart-type ….\n\nMean/var/sdmin/max/rangemédiane / quartiles / quantiles\n\n\nLa moyenne de \\(\\underline{x}\\) : \\(\\bar{x} = \\frac{1}{n} \\underset{i=1}{\\stackrel{n}{\\sum}} x_i\\)\n\nmean(Data$Alcool)\n\n[1] 10.48592\n\n\n\nLa variance \\(s_x^2 = \\frac{1}{n}\\underset{i=1}{\\stackrel{n}{\\sum}} (x_i - \\bar{x})^2\\)\nla variance corrigée \\(var(\\underline{x})=\\frac{1}{n-1}\\underset{i=1}{\\stackrel{n}{\\sum}} (x_i - \\bar{x})^2\\)\nl’écart-type corrigé \\(\\sqrt{var(\\underline{x})}\\)\n\nAttention les fonctions var() et sd() renvoient les valeurs corrigées de la variance et de l’écart-type respectivement.\n\nvar(Data$Alcool)\n\n[1] 1.316059\n\nsd(Data$Alcool)\n\n[1] 1.147196\n\n\n\n\nLa commande range() renvoie respectivement le minimum et le maximum. On peut aussi utiliser min()et max()\n\nrange(Data$Alcool)\n\n[1]  8 14\n\nmin(Data$Alcool)\n\n[1] 8\n\nmax(Data$Alcool)\n\n[1] 14\n\n\nOn peut alors récupérer l’étendue (\\(max(\\underline{x}) - min(\\underline{x})\\) ) avec le code suivant :\n\ndiff(range(Data$Alcool))\n\n[1] 6\n\n\n\n\nLa médiane est une valeur qui divise l’échantillon en deux sous-échantillons de même cardinal : \\(\\underset{i=1}{\\stackrel{n}{\\sum}} \\mathbb{1}_{x_i\\geq m} \\geq \\frac{n}{2} \\textrm{ et } \\underset{i=1}{\\stackrel{n}{\\sum}} \\mathbb{1}_{x_i\\leq m} \\geq \\frac{n}{2}\\)\n\nmedian(Data$Alcool)\n\n[1] 10.4\n\nsort(Data$Alcool)[296:305]\n\n [1] 10.3 10.3 10.3 10.3 10.4 10.4 10.4 10.4 10.4 10.4\n\n\nLa médiane est le deuxième des trois quartiles :\n\nle premier quartile \\(q_{0.25}\\) est une valeur qui sépare les 25\\(\\%\\) des valeurs inférieures de l’échantillon du reste\nle deuxième quartile \\(q_{0.5}\\) est la médiane\nle troisième quartile \\(q_{O.75}\\) est une valeur qui sépare les 25% des valeurs supérieures de l’échantillon du reste. On retrouve ces valeurs dans la représentation par boxplot (voir la sous-section boxplot).\n\nLes quartiles sont des cas particuliers de la notion de quantile. Le \\(\\alpha\\)-quantile empirique est défini par \\(q_{\\alpha} = x_{(i)}\\) avec \\(\\alpha\\in]\\frac{i-1}{n}, \\frac{i}{n}]\\) où \\(x_{(1)}\\leq x_{(2)}\\leq \\ldots \\leq x_{(n)}\\) sont les valeurs ordonnées de la série statistique.\n\nquantile(Data$Alcool)\n\n  0%  25%  50%  75% 100% \n 8.0  9.5 10.4 11.3 14.0 \n\nquantile(Data$Alcool,0.9)\n\n 90% \n12.1 \n\n\nPour calculer l’écart interquantile, il suffit de faire la différence entre les troisième et premier quantiles, à savoir\n\nq.Alc &lt;- quantile(x = Data$Alcool, probs=c(.25,.75), names=FALSE)\ndiff(q.Alc)\n\n[1] 1.8\n\n\nLes valeurs d’adjacence (cf définitions dans la sous-section boxplot) sont obtenues de la manière suivante :\n\nL=q.Alc + diff(q.Alc) * c(-1.5,1.5) ; L\n\n[1]  6.8 14.0\n\n# valeur adjacente inférieure :\nmin(Data$Alcool[Data$Alcool&gt;=L[1]])\n\n[1] 8\n\n# valeur adjacente supérieure :\nmax(Data$Alcool[Data$Alcool&lt;=L[2]])\n\n[1] 14\n\n\nPar ailleurs, toutes ces informations sont stockées dans la commande summary() :\n\nsummary(Data$Alcool)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   8.00    9.50   10.40   10.49   11.30   14.00 \n\n\noù sont affichés respectivement le minimum, le premier quartile, la médiane, la moyenne, le troisième quartile et le maximum.\n\n\n\n\n\nReprésentations graphiques\n\nHistogrammeFonction de répartition empiriqueBoîte à moustaches / boxplot\n\n\nL’histogramme est une représentation graphique qui permet de visualiser la répartition d’une variable quantitative. Les valeurs sont regroupées en intervalles \\(]a_k,a_{k+1}[\\) et la hauteur associée est \\(h_k=\\frac{f_k}{a_{k+1} - a_k}\\).\n\nggplotplot\n\n\n\ng1=ggplot(Data, aes(x=Alcool)) + \n  geom_histogram(color=\"black\", fill=\"white\",binwidth = 0.5)\ng2=ggplot(Data, aes(x=Alcool)) + \n  geom_histogram(aes(y=..density..),color=\"black\", fill=\"white\",binwidth = 0.5)\ngrid.arrange(g1,g2,ncol=2)\n\n\n\n\n\nggplot(Data, aes(x=Alcool)) + \n geom_histogram(aes(y=..density..), colour=\"black\", fill=\"white\")+\n geom_density(alpha=.2, fill=\"red\") \n\n\n\n\n\nggplot(Data, aes(x=Alcool, color=Type)) +\n  geom_histogram(aes(y=..density..),fill=\"white\")+\n  geom_density(alpha=.2) \n\n\n\n\n\n\n\npar(mfrow=c(1,2))\nhist(Data$Alcool,main=\"Histo. des effectifs\")\nhist(Data$Alcool,freq=FALSE,main=\"Histo. des fréquences\")\n\n\n\n\nL’option breaks=\"Sturges\" donne le choix par défaut de R pour le nombre de classes. D’autres options sont possibles (soit on précise les classes elles mêmes dans un vecteur, soit on précise un nombre arbitraire de classes, soit on lui précise l’algorithme pour calculer le nombre de classes parmi \"Sturges\", \"Scott\" ou \"FD\" pour Freedman-Diaconis). On peut récupérer les informations de construction de l’histogramme en stockant le résultat de hist() dans une variable :\n\nH &lt;- hist(Data$Alcool,plot=FALSE)\nattributes(H)\n\n$names\n[1] \"breaks\"   \"counts\"   \"density\"  \"mids\"     \"xname\"    \"equidist\"\n\n$class\n[1] \"histogram\"\n\n\n\nH$breaks # les (K+1) bordures des classes [a_k,a_{k+1}]\nH$counts # le nombre de points dans chaque classe\nH$density # la hauteur des K classes\nH$mids # le milieu des K classes\nH$xname # le nom de la variable\nH$equidist # découpage régulier \n\n\n\n\n\n\nLa fonction de répartition empirique est la fonction en escalier définie par \\(t\\in\\mathbb{R}\\mapsto F_n(t) = \\frac{1}{n} \\underset{i=1}{\\stackrel{n}{\\sum}} \\mathbb{1}_{x_i\\leq t}\\)\n\nggplotplot\n\n\n\nggplot(Data, aes(Alcool)) + \n  stat_ecdf(geom = \"step\")+\n  xlab(\"Variable Alcool\") +\n  ylab(\" \")+\n  ggtitle(\"Fonction de répartition empirique\")\n\n\n\n\n\n\n\nplot(ecdf(Data$Alcool), xlab = 'Variable Alcool', ylab = '', \nmain = 'Fonction de répartition empirique')\n\n\n\n\n\n\n\n\n\nLa boîte à moustaches est un graphique qui résume la série statistique à partir de ses valeurs extrêmes et ses quartiles. En effet, on retrouve sur cette représentation\n\nles quartiles\nla valeur adjacente supérieure \\(v+\\), qui est la plus grande valeur de l’échantillon inférieure ou égale à \\(L+ = q_{0.75} + 1.5 (q _{0.75} − q_{0.25})\\)\nla valeur adjacente inférieure \\(v−\\), qui est la plus petite valeur de l’échantillon supérieure ou égale à \\(L− = q_{0.25} − 1.5 (q_{0.75} − q_{0.25})\\)\nles valeurs extrêmes (outliers) qui sont les valeurs de l’échantillon n’appartenant pas à l’intervalle \\([v−, v+]\\).\n\n\nggplotplot\n\n\nReprésentation des boxplot avec ggplot2 :\n\ng1 = ggplot(gather(key=\"variable\",value=\"valeur\",Data[,c(3:4)]))+ \n  geom_boxplot(aes(x=variable, y=valeur))\ng2 = ggplot(gather(key=\"variable\",value=\"valeur\",Data[,c(5:6)]))+ \n  geom_boxplot(aes(x=variable, y=valeur))\ngrid.arrange(g1,g2,ncol=2)\n\n\n\n\nReprésentation des violin plots :\n\ng1 = ggplot(gather(key=\"variable\",value=\"valeur\",Data[,c(3:4)]))+ \n  geom_violin(aes(x=variable, y=valeur))\ng2 = ggplot(gather(key=\"variable\",value=\"valeur\",Data[,c(5:6)]))+ \n  geom_violin(aes(x=variable, y=valeur))\ngrid.arrange(g1,g2,ncol=2)\n\n\n\n\n\n\nVoici les boxplots pour les variables quantitatives de notre exemple.\n\nboxplot(Data[,-c(1:2)])\n\n\n\n\nNous allons pour la suite nous concentrer sur la variable SO2lbr. En plus du graphique, on peut récupérer de la fonction boxplot() différentes informations :\n\nB &lt;- boxplot(Data$SO2lbr,horizontal=TRUE)\n\n\n\nattributes(B)\n\n$names\n[1] \"stats\" \"n\"     \"conf\"  \"out\"   \"group\" \"names\"\n\n\nDans B$stats, on retrouve les quartiles, la médiane et les valeurs adjacentes :\n\nB$stats\n\n     [,1]\n[1,]  2.0\n[2,] 15.5\n[3,] 27.0\n[4,] 41.0\n[5,] 73.5\n\nmedian(Data$SO2lbr)\n\n[1] 27\n\nq &lt;- quantile(x = Data$SO2lbr, probs=c(.25,.75), names=FALSE)\nq\n\n[1] 15.75 41.00\n\nL=q + diff(q) * c(-1.5,1.5) \nmin(Data$SO2lbr[Data$SO2lbr&gt;=L[1]])\n\n[1] 2\n\nmax(Data$SO2lbr[Data$SO2lbr&lt;=L[2]])\n\n[1] 73.5\n\n\nB$out renvoie toutes les valeurs aberrantes (en dehors des barres inférieure et supérieure c’est à dire en dehors de l’intervalle \\([v-,v+]\\)):\n\nB$out\n\n[1]  89.0 105.0  85.0 112.0  79.5\n\nData$SO2lbr[which(Data$SO2lbr&lt;B$stats[1] | Data$SO2lbr&gt;B$stats[5])]\n\n[1]  89.0 105.0  85.0 112.0  79.5\n\n\n\n\n\n\n\n\n\n\n\n3.2.3 Statistiques descriptives bidimensionnelles\n\nEntre 2 variables quantitatives\nSupposons dans cette partie que X et Y sont deux variables quantitatives et on observe une série de \\(n\\) valeurs pour chacune : \\(\\underline{x}=(x_1,\\ldots,x_n)\\) et \\(\\underline{y}=(y_1,\\ldots,y_n)\\).\nOn peut tout d’abord représenter le nuage de points de coordonnées \\((x_i,y_i)\\) :\n\nggplotplot\n\n\n\nggplot(Data,aes(x=Alcool,y=Densite))+\n  geom_point()\n\n\n\n\n\n\n\nplot(Data$Alcool,Data$Densite,pch=20,xlab=\"Alcool\",ylab=\"Densite\")\n\n\n\n\n\n\n\n\nCorrélation\nOn peut calculer la covariance (généralisaton bidimensionnelle de la variance) entre ces deux séries de mesure à l’aide de la commande cov(): \\[\nCov(\\underline{x},\\underline{y}) = \\frac{1}{n} \\underset{i=1}{\\stackrel{n}{\\sum}} (x_i-\\bar{x}) (y_i -\\bar{y}).\n\\] Mais la covariance dépendant des unités de mesure des deux variables considérées, on calcule plutôt la corrélation linéaire (renormalisation de la covariance par les écarts-type) qui appartient à l’intervalle \\([-1,1]\\) à l’aide de cor(): \\[\ncor(\\underline{x},\\underline{y}) = \\frac{Cov(\\underline{x},\\underline{y})}{\\sqrt{s_x^2\\ \\ s_y^2}}\n\\]\n\ncorrplot()ggcorrplot()\n\n\nA l’aide de la fonction corrplot() (issue du package du même nom) on représente ici la matrice des corrélations entre les variables quantitatives de notre jeu de données:\n\ncorrplot(cor(Data[,-c(1:2)]),method=\"ellipse\")\n\n\n\n\n\n\n\nggcorrplot(cor(Data[,-c(1:2)]),method = \"circle\")\n\n\n\n\n\nggcorrplot(cor(Data[,-c(1:2)]),hc.order = TRUE, type = \"lower\",\n   lab = TRUE)\n\n\n\n\n\n\n\n\n\nRégression linéaire\nLe coefficient de corrélation linéaire entre les variables Densité et Alcool vaut -0.68. On peut vérifier que le nuage de points de ces deux variables s’aligner sur une droite de pente négative :\n\nggplotplot\n\n\n\nggplot(Data,aes(x=Alcool,y=Densite))+\n  geom_point()+\n  geom_smooth(method=lm)\n\n\n\n\n\n\n\nplot(Densite ~ Alcool, data=Data,pch=20)\nabline(lm(Densite~Alcool,data=Data),col=\"red\")\n\n\n\n\n\n\n\n\n\n\nEntre une variable quantitative et une variable qualitative\nSupposons dans cette partie que \\(X\\) est une variable qualitative prenant \\(J\\) modalités \\(m_1, \\ldots, m_J\\) et \\(Y\\) une variable quantitative. On observe une série de \\(n\\) valeurs pour chacune : \\(\\underline{x}=(x_1,\\ldots,x_n)\\) et \\(\\underline{y}=(y_1,\\ldots,y_n)\\).\nOn note \\(C_j=\\{i\\in\\{1,\\ldots,n\\}; x_i=m_j\\}\\) l’ensemble des individus prenant la modalité \\(m_j\\) et \\(n_j\\) son cardinal.\nLa moyenne de \\(\\underline{y}\\) peut alors se décomposer en une moyenne pondérée des moyennes de \\(y\\) conditionnellement aux modalités de \\(X\\) : \\[\n\\bar{y} = \\frac{1}{n} \\sum_{j=1}^J n_j\\ \\bar{y}_{[j]} \\textrm{   avec   } \\bar{y}_{[j]} = \\frac{1}{n_j} \\sum_{i\\in C_j} y_i\n\\] De même la variance se décompose en \\(s_y^2 = \\underbrace{s_{y,E}^2}_{\\textrm{variance inter-classe}} + \\underbrace{s_{y,R}^2}_{\\textrm{variance intra-classe}}\\) avec\n\\[\ns_{y,E}^2 = \\frac{1}{n} \\sum_{j=1}^J n_j\\ (\\bar{y}_{[j]} - \\bar{y})^2\n\\] et \\[\ns_{y,R}^2 = \\frac{1}{n} \\sum_{j=1}^J n_j\\ s_{y,[j]}^2 \\textrm{ avec } s^2_{y,[j]} = \\frac{1}{n_j}\\sum_{i\\in C_j} (y_i - \\bar{y}_{[j]})^2\n\\] On peut alors définir le rapport de corrélation \\[\n\\rho_{y|x} = \\sqrt{\\frac{s_{y,E}^2}{s_{y}^2}} = \\sqrt{1 - \\frac{s_{y,R}^2}{s_{y}^2}}\\in[0,1].\n\\] Plus \\(\\rho_{y|x}\\) est proche de \\(0\\), plus \\(s_{y,E}^2\\) est proche de 0 et donc moins la variable qualitative \\(X\\) a d’influence sur la variable quantitative \\(Y\\).\nGraphiquement, on peut représenter la distribution de la variable quantitative conditionnellement aux modalités de la variable qualitative pour visualiser la liaison potentielle entre les deux variables.\n\nggplotplot\n\n\n\ng1=ggplot(Data,aes(x=Qualite,y=Alcool))+\n  geom_boxplot()\ng2=ggplot(Data,aes(x=Qualite,y=Alcool))+\n  geom_violin()\ng3=ggplot(Data,aes(x=Alcool,fill=Qualite))+\n  geom_density(alpha=0.2)\ngrid.arrange(g1,g2,g3,ncol=2)\n\n\n\n\n\n\n\npar(mfrow=c(1,2))\nboxplot(Alcool~Qualite,data=Data)\nboxplot(Alcool~Type,data=Data)\n\n\n\n\n\n\n\n\n\nEntre deux variables qualitatives\nSupposons dans cette partie que \\(X\\) est une variable qualitative prenant \\(J\\) modalités \\(m_1,\\ldots,m_J\\) et \\(Y\\) est une vraiable qualitative prenant \\(K\\) modalités \\(\\ell_1,\\ldots,\\ell_K\\). On observe une série de \\(n\\) valeurs pour chacune : \\(\\underline{x}=(x_1,\\ldots,x_n)\\) et \\(\\underline{y}=(y_1,\\ldots,y_n)\\). Pour étudier l’influence de deux variables qualitatives entre elles, on se base sur la table de contingence qui est l’ensemble des effectifs conjoints \\[\nn_{j,k} = \\sum_{i=1}^n \\mathrm{1}_{x_i = m_j\\ \\cap\\ y_i=\\ell_k},\\ \\ \\forall j\\in\\{1,\\ldots,J\\},\\ \\forall k\\in\\{1,\\ldots,K\\}\n\\] On définit les effectifs marginaux par \\[\nn_{j,.}=\\sum_{k=1}^K n_{j,k}\\ \\ \\ \\textrm{   et   } \\ \\ \\ n_{.,k}=\\sum_{j=1}^J n_{j,k}\n\\]\n\ntable.cont = table(Data$Qualite,Data$Type)\ntable.cont\n\n        \n         blanc rouge\n  bad       17     2\n  good      89    21\n  medium   319   152\n\n\nGraphiquement, on peut représenter un mosaicplot qui correspond à la représentation des profils-lignes \\[\n\\left(\\frac{n_{j,1}}{n_{j,.}},\\ldots,\\frac{n_{j,K}}{n_{j,.}}\\right)\\in [0,1]^K\n\\] ou des profils-colonnes\n\\[\n\\left(\\frac{n_{1,k}}{n_{.,k}},\\ldots,\\frac{n_{J,k}}{n_{.,k}}\\right)\\in [0,1]^J\n\\]\n\nggplotplot\n\n\n\nlibrary(ggmosaic)\nggplot(data = Data) +\n   geom_mosaic(aes(x = product(Type, Qualite), fill=Qualite), na.rm=TRUE)+\n   xlab(\"Qualite\")+\n   ylab(\"Type\")\n\n\n\nggplot(data = Data) +\n   geom_mosaic(aes(x = product(Qualite, Type)), na.rm=TRUE)+\n   xlab(\"Type\")+\n   ylab(\"Qualite\")\n\n\n\n\n\n\n\nmosaicplot(table(Data$Qualite,Data$Type))\n\n\n\nmosaicplot(table(Data$Type,Data$Qualite))"
  },
  {
    "objectID": "Part3-StatR.html#pour-aller-plus-loin",
    "href": "Part3-StatR.html#pour-aller-plus-loin",
    "title": "3  Statistique avec R",
    "section": "3.3 Pour aller plus loin",
    "text": "3.3 Pour aller plus loin\nDans la suite de votre cursus modIA, vous aborderez la mise en pratique d’algorithmes en R et python sur les thématiques suivantes :\n\nles statistiques descriptives multidimensionnelles dont l’ACP\nle modèle linéaire et modèle linéaire généralisé\nl’apprentissage supervisé\nl’apprentissage non supervisé\n…"
  },
  {
    "objectID": "Part4-Ravance.html#le-package-tidyverse",
    "href": "Part4-Ravance.html#le-package-tidyverse",
    "title": "4  Pour aller plus loin avec R et RStudio",
    "section": "4.1 Le package tidyverse ",
    "text": "4.1 Le package tidyverse \n\n4.1.1 Principe\nLe terme tidyverse est une contraction de tidy (“bien rangé”) et de universe. C’est une collection d’extensions conçues pour travailler ensemble, avec des fonctions de syntaxe cohérente et compatibles, et basées sur une philosophie commune. Ces extensions sont en grande partie dues à Hadley Wickham.\nEn installant le package tidyverse, on installe plusieurs extensions qui constituent le “coeur” :\n\nggplot2 (visualisation)\ndplyr (manipulation des données)\ntidyr (remise en forme des données)\npurrr (programmation)\nreadr (importation de données)\ntibble (tableaux de données)\nforcats (variables qualitatives)\nstringr (chaînes de caractères)\n\n\n\n\n\n\nLibrairies dans tidyverse\n\n\n\n\nElles sont automatiquement chargées avec la commande library(tidyverse). On peut aussi les charger une à une (par exemple library(ggplot2)). La liste complète des extensions de tidyverse se trouve sur le site officiel du tidyverse.\nLa philosophie de tidyverse est basée sur le concept de tidy data, développé à l’origine par Hadley Wickham dans l’article “Tidy Data.” Journal of Statistical Software (2014). L’idée est d’organiser les données pour faciliter le travail de préparation des données avant l’analyse statistique. Les principes des données tidy sont :\n\nchaque variable est une colonne\nchaque observation est une ligne\nchaque type d’observation est dans une table différente\n\nUne autre particularité du tidyverse est que les packages de tidyverse travaillent avec des tableaux de données de type tibble (géré avec le package du même nom), qui est une évolution du format data.frame de R. On peut convertir un data.frame en tibble avec la commande as_tibble(), et un tibble en data.frame avec as.data.frame().\nPour la suite de ce tutoriel, installez et chargez la librairie tidyverse:\n\ninstall.packages(\"tidyverse\")\nlibrary(tidyverse)\n\nPour la suite, nous utiliserons le jeu de données wine disponible dans le dossier “Data/” , qui nous a déjà servi dans la partie 3.\n\nWine=read.table(\"Data/wine.txt\",header=TRUE)\n\n\nhead(Wine)\n\n     Qualite Type AcidVol AcidCitr SO2lbr SO2tot Densite Alcool\n1352  medium    1    0.62     0.01      8     46 0.99332   11.8\n5493  medium    0    0.34     0.10     17     63 0.99370    9.2\n5153  medium    0    0.22     0.22     39    110 0.99855    9.0\n5308  medium    0    0.35     0.46     61    183 0.99786    9.0\n3866  medium    0    0.42     0.32     20    167 0.99479   10.6\n694   medium    1    0.48     0.32     21    122 0.99840    9.4\n\nclass(Wine)\n\n[1] \"data.frame\"\n\nhas_rownames(Wine)\n\n[1] TRUE\n\nWine.tbl = as_tibble(rownames_to_column(Wine))\nWine.tbl\n\n# A tibble: 600 × 9\n   rowname Qualite  Type AcidVol AcidCitr SO2lbr SO2tot Densite Alcool\n   &lt;chr&gt;   &lt;chr&gt;   &lt;int&gt;   &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;  &lt;int&gt;   &lt;dbl&gt;  &lt;dbl&gt;\n 1 1352    medium      1    0.62     0.01      8     46   0.993   11.8\n 2 5493    medium      0    0.34     0.1      17     63   0.994    9.2\n 3 5153    medium      0    0.22     0.22     39    110   0.999    9  \n 4 5308    medium      0    0.35     0.46     61    183   0.998    9  \n 5 3866    medium      0    0.42     0.32     20    167   0.995   10.6\n 6 694     medium      1    0.48     0.32     21    122   0.998    9.4\n 7 5085    good        0    0.21     0.32     39    113   0.994   10.2\n 8 2280    medium      0    0.28     0.14     64    159   0.992   10  \n 9 5231    medium      0    0.3      0.25     21    124   0.994   10.8\n10 4388    medium      0    0.4      0.42     41    176   0.996    9.4\n# ℹ 590 more rows\n\n\n\n\n4.1.2 Manipulation de variables qualitatives avec forcats \nLes variables qualitatives peuvent être de deux types sous R, characteret factor, ce qui amène parfois à des erreurs de manipulation et d’utilisation de fonctions non adaptées au type de la variable qualitative étudiée. forcats est une extension de tidyverse qui permet de faciliter la manipulation des variables qualitatives quelque soit leur type. Voici quelques fonctions utiles de forcast :\n\nfct_recode() : permet de recoder les modalités d’une variable qualitative\nfct_collapse() : permet de regrouper des modalités\nfct_other(): permet de regrouper une liste de modalités dans une seule modalité “Other”\nfct_lump(): permet de regrouper automatiquement les modalités les moins fréquentes (seuil modifiable) en une seule modalité “Other”\nfct_explicit_na(): permet de recoder les données manquantes NA en une modalité choisie\nfct_relevel() : permet d’ordonner manuellement les modalités d’une variable qualitative\nfct_reorder(): permet d’ordonner les modalités d’une variable qualitative en fonction d’une autre variable à laquelle on applique une fonction donnée en argument\nfct_infreq() : permet d’ordonner les modalités selon les effectifs\n\nL’extension questionr propose une interface graphique pour recoder les modalités d’une variable qualitative. On peut aussi se servir de cette interface pour découper une variable quantitative en classes (pour faire comme la fonction cut()).\n\nlibrary(questionr)\nWine$Type=as.factor(Wine$Type)\nWine$Type=fct_recode(Wine$Type,\"blanc\"=\"0\",\"rouge\"=\"1\")\nfreq(Wine$Type)\n\n        n    % val%\nblanc 425 70.8 70.8\nrouge 175 29.2 29.2\n\nfreq(Wine$Qualite)\n\n         n    % val%\nbad     19  3.2  3.2\ngood   110 18.3 18.3\nmedium 471 78.5 78.5\n\nQualite = fct_recode(Wine$Qualite,\"mauvais\"=\"bad\",\"bon\"=\"good\")\nfreq(Qualite)\n\n          n    % val%\nmauvais  19  3.2  3.2\nbon     110 18.3 18.3\nmedium  471 78.5 78.5\n\nfreq(fct_relevel(Wine$Qualite, \"good\",\"bad\",\"medium\"))\n\n         n    % val%\ngood   110 18.3 18.3\nbad     19  3.2  3.2\nmedium 471 78.5 78.5\n\nggplot(Wine)+\n   geom_boxplot(aes(x = fct_reorder(Qualite, Alcool, median), \n                   y = Alcool))+\n  xlab(\"Qualite\")\n\n\n\nggplot(Wine) +\n  geom_bar(aes(x = fct_infreq(Qualite)))+\n  xlab(\"Qualite\")\n\n\n\n\n\n\n4.1.3 Manipulation avec dplyr \ndplyr est une extension pour le traitement et la manipulation de données contenues dans un ou plusieurs tableaux. Elle considère que les données sont organisées selon le tidy data, ses fonctions s’appliquent sur des tibble ou des data.frame et renvoient le résultat sous forme d’un tibble. Nous allons illustrer ici les fonctions principales disponibles dans dplyr.\n\nslice()filter()select()arrange()Le pipe %&gt;%if_else() / case_when()group_by()summarise()mutate() / transmute()\n\n\nLa fonction slice() permet de sélectionner des lignes du tableau selon leur position. Par exemple si on souhaite accéder à la 20ème ligne du jeu de données Wine:\n\nslice(Wine.tbl,20)\n\n# A tibble: 1 × 9\n  rowname Qualite  Type AcidVol AcidCitr SO2lbr SO2tot Densite Alcool\n  &lt;chr&gt;   &lt;chr&gt;   &lt;int&gt;   &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;  &lt;int&gt;   &lt;dbl&gt;  &lt;dbl&gt;\n1 6420    medium      0    0.36      0.5     63    178   0.992    9.7\n\n\n\n\nLa fonction filter() filtre les lignes d’une table selon une condition. Seules les lignes pour lesquelles le test renvoie TRUE sont conservées.\nPar exemple, si on veut ne conserver que les vins de Qualité “medium” :\n\nfilter(Wine.tbl,Qualite==\"medium\")\n\n# A tibble: 471 × 9\n   rowname Qualite  Type AcidVol AcidCitr SO2lbr SO2tot Densite Alcool\n   &lt;chr&gt;   &lt;chr&gt;   &lt;int&gt;   &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;  &lt;int&gt;   &lt;dbl&gt;  &lt;dbl&gt;\n 1 1352    medium      1    0.62     0.01      8     46   0.993   11.8\n 2 5493    medium      0    0.34     0.1      17     63   0.994    9.2\n 3 5153    medium      0    0.22     0.22     39    110   0.999    9  \n 4 5308    medium      0    0.35     0.46     61    183   0.998    9  \n 5 3866    medium      0    0.42     0.32     20    167   0.995   10.6\n 6 694     medium      1    0.48     0.32     21    122   0.998    9.4\n 7 2280    medium      0    0.28     0.14     64    159   0.992   10  \n 8 5231    medium      0    0.3      0.25     21    124   0.994   10.8\n 9 4388    medium      0    0.4      0.42     41    176   0.996    9.4\n10 4172    medium      0    0.14     0.28     10     56   0.994    9.9\n# ℹ 461 more rows\n\n\nSi on veut ne conserver que les vins avec au moins 11 degrés d’alcool et une teneur en acide volatile de moins de 0.3 :\n\nfilter(Wine.tbl,Alcool&gt;=11 & AcidVol&lt;0.3)\n\n# A tibble: 99 × 9\n   rowname Qualite  Type AcidVol AcidCitr SO2lbr SO2tot Densite Alcool\n   &lt;chr&gt;   &lt;chr&gt;   &lt;int&gt;   &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;  &lt;int&gt;   &lt;dbl&gt;  &lt;dbl&gt;\n 1 2155    good        0    0.25     0.34     31     93   0.992   11.3\n 2 2258    medium      0    0.27     0.25     41    188   0.992   11.3\n 3 4560    good        0    0.11     0.34     41    114   0.996   11  \n 4 5430    good        0    0.26     0.23     23    111   0.993   11.5\n 5 6496    good        0    0.29     0.3      20    110   0.989   12.8\n 6 3046    medium      0    0.27     0.49     35     92   0.991   12.2\n 7 4690    medium      0    0.17     0.35     33     78   0.991   11.3\n 8 4799    good        0    0.21     0.4      40    121   0.992   12  \n 9 5167    medium      0    0.26     0.27     20     80   0.991   11.5\n10 5291    medium      0    0.22     0.26     23    112   0.993   11.4\n# ℹ 89 more rows\n\n\nSi on veut filtrer les vins ayant un taux d’alcool entre 10.5 et 11 :\n\nfilter(Wine.tbl,between(Alcool,10.5,11))\n\n# A tibble: 94 × 9\n   rowname Qualite  Type AcidVol AcidCitr SO2lbr SO2tot Densite Alcool\n   &lt;chr&gt;   &lt;chr&gt;   &lt;int&gt;   &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;  &lt;int&gt;   &lt;dbl&gt;  &lt;dbl&gt;\n 1 3866    medium      0    0.42     0.32     20    167   0.995   10.6\n 2 5231    medium      0    0.3      0.25     21    124   0.994   10.8\n 3 4560    good        0    0.11     0.34     41    114   0.996   11  \n 4 3615    medium      0    0.19     0.39     22     84   0.994   10.8\n 5 2983    medium      0    0.36     0.56     25    102   0.992   10.5\n 6 6347    medium      0    0.26     0.5      25     93   0.994   10.5\n 7 3003    good        0    0.26     0.31     29    128   0.994   10.9\n 8 1291    medium      1    0.74     0         6     12   0.995   11  \n 9 1350    medium      1    0.57     0        21     41   0.995   10.8\n10 6336    medium      0    0.16     0.36     13     61   0.991   10.8\n# ℹ 84 more rows\n\n\n\n\nLa fonction select() permet de sélectionner des colonnes d’une table. Nous donnons quelques exemples ci-dessous. On renvoie à l’aide ?select pour voir les options disponibles pour sélectionner plusieurs colonnes, sélectionner selon une condition sur les noms, … On peut aussi utiliser la fonction rename() (voir l’aide.)\nDans notre exemple, si on veut récupérer les variables Alcool et Qualite\n\nselect(Wine.tbl,Alcool,Qualite)\n\n# A tibble: 600 × 2\n   Alcool Qualite\n    &lt;dbl&gt; &lt;chr&gt;  \n 1   11.8 medium \n 2    9.2 medium \n 3    9   medium \n 4    9   medium \n 5   10.6 medium \n 6    9.4 medium \n 7   10.2 good   \n 8   10   medium \n 9   10.8 medium \n10    9.4 medium \n# ℹ 590 more rows\n\n\nSi on veut éliminer les variables AcidVol et SO2tot :\n\nselect(Wine.tbl,-AcidVol,-SO2tot)\n\n# A tibble: 600 × 7\n   rowname Qualite  Type AcidCitr SO2lbr Densite Alcool\n   &lt;chr&gt;   &lt;chr&gt;   &lt;int&gt;    &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt;\n 1 1352    medium      1     0.01      8   0.993   11.8\n 2 5493    medium      0     0.1      17   0.994    9.2\n 3 5153    medium      0     0.22     39   0.999    9  \n 4 5308    medium      0     0.46     61   0.998    9  \n 5 3866    medium      0     0.32     20   0.995   10.6\n 6 694     medium      1     0.32     21   0.998    9.4\n 7 5085    good        0     0.32     39   0.994   10.2\n 8 2280    medium      0     0.14     64   0.992   10  \n 9 5231    medium      0     0.25     21   0.994   10.8\n10 4388    medium      0     0.42     41   0.996    9.4\n# ℹ 590 more rows\n\n\nSi on veut récupérer les colonnes dont le nom commence par Acid\n\nselect(Wine.tbl,starts_with(\"Acid\"))\n\n# A tibble: 600 × 2\n   AcidVol AcidCitr\n     &lt;dbl&gt;    &lt;dbl&gt;\n 1    0.62     0.01\n 2    0.34     0.1 \n 3    0.22     0.22\n 4    0.35     0.46\n 5    0.42     0.32\n 6    0.48     0.32\n 7    0.21     0.32\n 8    0.28     0.14\n 9    0.3      0.25\n10    0.4      0.42\n# ℹ 590 more rows\n\n\nSi on veut récupérer les colonnes qui contiennent Acid :\n\nselect(Wine.tbl,contains(\"Acid\"))\n\n# A tibble: 600 × 2\n   AcidVol AcidCitr\n     &lt;dbl&gt;    &lt;dbl&gt;\n 1    0.62     0.01\n 2    0.34     0.1 \n 3    0.22     0.22\n 4    0.35     0.46\n 5    0.42     0.32\n 6    0.48     0.32\n 7    0.21     0.32\n 8    0.28     0.14\n 9    0.3      0.25\n10    0.4      0.42\n# ℹ 590 more rows\n\n\n\n\nLa fonction `arrange() permet de réordonner les lignes du jeu de données en fonction d’une ou plusieurs variables.\nPar exemple, pour ordonner les lignes de Wine en fonction des valeurs de la variable Alcool\n\narrange(Wine.tbl,Alcool)\n\n# A tibble: 600 × 9\n   rowname Qualite  Type AcidVol AcidCitr SO2lbr SO2tot Densite Alcool\n   &lt;chr&gt;   &lt;chr&gt;   &lt;int&gt;   &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;  &lt;int&gt;   &lt;dbl&gt;  &lt;dbl&gt;\n 1 4225    medium      0    0.19     0.21     89    159   0.993    8  \n 2 3185    medium      0    0.3      0.74     46    165   0.998    8.7\n 3 2830    medium      0    0.29     0.3      46    238   0.999    8.7\n 4 5650    good        0    0.16     0.27     25    135   0.998    8.7\n 5 5278    medium      0    0.23     0.25     19    111   1.00     8.7\n 6 1741    medium      0    0.37     0.67     49    155   0.998    8.7\n 7 1684    medium      0    0.43     0.61     54    155   0.997    8.7\n 8 1737    medium      0    0.37     0.67     49    155   0.998    8.7\n 9 3258    medium      0    0.31     0.49     52    220   0.996    8.8\n10 1477    medium      1    0.5      0.5      48     82   1.00     8.8\n# ℹ 590 more rows\n\n\nPour trier par ordre décroissant, on utilise la fonction desc()\n\narrange(Wine.tbl,desc(Alcool))\n\n# A tibble: 600 × 9\n   rowname Qualite  Type AcidVol AcidCitr SO2lbr SO2tot Densite Alcool\n   &lt;chr&gt;   &lt;chr&gt;   &lt;int&gt;   &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;  &lt;int&gt;   &lt;dbl&gt;  &lt;dbl&gt;\n 1 5504    good        0   0.455     0.18     33    106   0.987   14  \n 2 6389    medium      0   0.62      0.33     24    118   0.988   13.6\n 3 5729    good        0   0.34      0.31     18     68   0.990   13.4\n 4 5103    good        0   0.33      0.31     21     93   0.990   13.4\n 5 5795    good        0   0.45      0.24     24     87   0.989   13.4\n 6 492     good        1   0.41      0.5      12     25   0.995   13.3\n 7 4973    good        0   0.28      0.24     49    121   0.989   13.2\n 8 6437    medium      0   0.28      0.38     54    216   0.992   13.1\n 9 5099    good        0   0.33      0.3      30    124   0.989   13.1\n10 1288    medium      1   0.6       0.08      3      7   0.993   13  \n# ℹ 590 more rows\n\n\nPour trier selon les deux variables Qualite et Alcool :\n\narrange(Wine.tbl,Qualite,Alcool)\n\n# A tibble: 600 × 9\n   rowname Qualite  Type AcidVol AcidCitr SO2lbr SO2tot Densite Alcool\n   &lt;chr&gt;   &lt;chr&gt;   &lt;int&gt;   &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;  &lt;int&gt;   &lt;dbl&gt;  &lt;dbl&gt;\n 1 5812    bad         0    0.31     0.37     13    164   0.996    8.8\n 2 3937    bad         0    0.28     0.35     61    180   0.997    9  \n 3 460     bad         1    0.58     0.66     10     47   1.00     9  \n 4 2226    bad         0    0.56     0.12     22    177   0.998    9.1\n 5 2262    bad         0    0.57     0.1      23    188   0.997    9.2\n 6 4131    bad         0    0.54     0.27      8    178   0.995    9.4\n 7 3074    bad         0    0.25     0.24     13     85   0.994    9.5\n 8 1646    bad         0    0.45     0.26     63    206   0.994    9.8\n 9 4000    bad         0    0.19     0.42     16    104   0.995   10  \n10 4001    bad         0    0.16     0.49     18    107   0.995   10.2\n# ℹ 590 more rows\n\n\nOn peut remarquer que l’on obtient le même résultat avec la commande\n\nWine.tbl %&gt;% arrange(Qualite,Alcool)\n\n# A tibble: 600 × 9\n   rowname Qualite  Type AcidVol AcidCitr SO2lbr SO2tot Densite Alcool\n   &lt;chr&gt;   &lt;chr&gt;   &lt;int&gt;   &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;  &lt;int&gt;   &lt;dbl&gt;  &lt;dbl&gt;\n 1 5812    bad         0    0.31     0.37     13    164   0.996    8.8\n 2 3937    bad         0    0.28     0.35     61    180   0.997    9  \n 3 460     bad         1    0.58     0.66     10     47   1.00     9  \n 4 2226    bad         0    0.56     0.12     22    177   0.998    9.1\n 5 2262    bad         0    0.57     0.1      23    188   0.997    9.2\n 6 4131    bad         0    0.54     0.27      8    178   0.995    9.4\n 7 3074    bad         0    0.25     0.24     13     85   0.994    9.5\n 8 1646    bad         0    0.45     0.26     63    206   0.994    9.8\n 9 4000    bad         0    0.19     0.42     16    104   0.995   10  \n10 4001    bad         0    0.16     0.49     18    107   0.995   10.2\n# ℹ 590 more rows\n\n\nCette commande pipe %&gt;% est importante dans dplyr.\n\n\nOn est souvent amené à enchaîner plusieurs opérations sur un tableau. Par exemple,\n\narrange(select(filter(Wine.tbl,Alcool&gt;=11),Qualite,Alcool),Qualite)\n\n# A tibble: 205 × 2\n   Qualite Alcool\n   &lt;chr&gt;    &lt;dbl&gt;\n 1 bad       11.5\n 2 bad       11.6\n 3 bad       11.5\n 4 bad       11.2\n 5 bad       11.2\n 6 good      12.7\n 7 good      11.3\n 8 good      11  \n 9 good      11.5\n10 good      12.8\n# ℹ 195 more rows\n\n\nmais cet enchainement de fonctions est peu lisible. On peut améliorer la lisibilité du code en utilisant le pipe, noté %&gt;%. Si on execute `expr%&gt;%f, le résultat de expr est passé comme premier argument de la fonction f, ce qui revient à executer f(expr). Ainsi notre exemple précédent peut se réécrire avec le code suivant :\n\nWine.tbl %&gt;% \n  filter(Alcool&gt;=11) %&gt;% \n  select(Qualite,Alcool) %&gt;% \n  arrange(Qualite)\n\n# A tibble: 205 × 2\n   Qualite Alcool\n   &lt;chr&gt;    &lt;dbl&gt;\n 1 bad       11.5\n 2 bad       11.6\n 3 bad       11.5\n 4 bad       11.2\n 5 bad       11.2\n 6 good      12.7\n 7 good      11.3\n 8 good      11  \n 9 good      11.5\n10 good      12.8\n# ℹ 195 more rows\n\n\n\n\nCes fonctions permettent de créer une nouvelle variable à partir d’une ou plusieurs variables existantes en faisant un ou des tests. La fonction if_else() prend en argument un test, une valeur à renvoyer si le test est vrai, et une valeur à renvoyer si le test est faux. case_when() généralise if_else() en permettant de considérer plusieurs tests et leurs valeurs associées en même temps. Mais attention, les conditions étant testées l’une après l’autre, l’ordre des tests est important.\n\nhead(cbind(Wine$Alcool,if_else(Wine$Alcool&gt;11,\"Alcool sup. à 11\", \"Alcool inf. à 11\")))\n\n     [,1]   [,2]              \n[1,] \"11.8\" \"Alcool sup. à 11\"\n[2,] \"9.2\"  \"Alcool inf. à 11\"\n[3,] \"9\"    \"Alcool inf. à 11\"\n[4,] \"9\"    \"Alcool inf. à 11\"\n[5,] \"10.6\" \"Alcool inf. à 11\"\n[6,] \"9.4\"  \"Alcool inf. à 11\"\n\n\n\nnew &lt;- case_when(\n    Wine$Alcool &gt; 11 & Wine$Type == \"rouge\" ~ \"vins rouges de degré sup. à 11\",\n    Wine$Alcool &gt; 11 & Wine$Type == \"blanc\"  ~ \"vins blancs de degré sup. à 11\",\n    TRUE ~ \"Autre\")\nfreq(new)\n\n                                 n    % val%\nAutre                          413 68.8 68.8\nvins blancs de degré sup. à 11 142 23.7 23.7\nvins rouges de degré sup. à 11  45  7.5  7.5\n\n\n\n\nLa fonction group_by() permet de créer des groupes de lignes à partir des valeurs d’une ou plusieurs variables. Par exemple on peut regrouper les vins selon leur qualité :\n\nWine.tbl %&gt;% group_by(Qualite)\n\n# A tibble: 600 × 9\n# Groups:   Qualite [3]\n   rowname Qualite  Type AcidVol AcidCitr SO2lbr SO2tot Densite Alcool\n   &lt;chr&gt;   &lt;chr&gt;   &lt;int&gt;   &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;  &lt;int&gt;   &lt;dbl&gt;  &lt;dbl&gt;\n 1 1352    medium      1    0.62     0.01      8     46   0.993   11.8\n 2 5493    medium      0    0.34     0.1      17     63   0.994    9.2\n 3 5153    medium      0    0.22     0.22     39    110   0.999    9  \n 4 5308    medium      0    0.35     0.46     61    183   0.998    9  \n 5 3866    medium      0    0.42     0.32     20    167   0.995   10.6\n 6 694     medium      1    0.48     0.32     21    122   0.998    9.4\n 7 5085    good        0    0.21     0.32     39    113   0.994   10.2\n 8 2280    medium      0    0.28     0.14     64    159   0.992   10  \n 9 5231    medium      0    0.3      0.25     21    124   0.994   10.8\n10 4388    medium      0    0.4      0.42     41    176   0.996    9.4\n# ℹ 590 more rows\n\n\nDans l’affichage, on voit apparaitre “Groups” dans les premières lignes, le reste n’a pas changé. Mais une fois les groupes créés, ils peuvent être utilisés dans les différentes fonctions de dplyr SAUF pour arrange().\nSi on veut grouper selon plusieurs variables, il suffit de les passer en argument de group_by():\n\nWine.tbl %&gt;% group_by(Qualite,Type)\n\n# A tibble: 600 × 9\n# Groups:   Qualite, Type [6]\n   rowname Qualite  Type AcidVol AcidCitr SO2lbr SO2tot Densite Alcool\n   &lt;chr&gt;   &lt;chr&gt;   &lt;int&gt;   &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;  &lt;int&gt;   &lt;dbl&gt;  &lt;dbl&gt;\n 1 1352    medium      1    0.62     0.01      8     46   0.993   11.8\n 2 5493    medium      0    0.34     0.1      17     63   0.994    9.2\n 3 5153    medium      0    0.22     0.22     39    110   0.999    9  \n 4 5308    medium      0    0.35     0.46     61    183   0.998    9  \n 5 3866    medium      0    0.42     0.32     20    167   0.995   10.6\n 6 694     medium      1    0.48     0.32     21    122   0.998    9.4\n 7 5085    good        0    0.21     0.32     39    113   0.994   10.2\n 8 2280    medium      0    0.28     0.14     64    159   0.992   10  \n 9 5231    medium      0    0.3      0.25     21    124   0.994   10.8\n10 4388    medium      0    0.4      0.42     41    176   0.996    9.4\n# ℹ 590 more rows\n\n\n\n\nLa fonction summarise() permet de calculer quelques indicateurs statistiques sur une ou plusieurs variables. Par exemple, si on veut connaitre la teneur moyenne en acide volatile de tous les vins\n\nWine.tbl %&gt;% summarise(AcidVolmean = mean(AcidVol, na.rm=TRUE))\n\n# A tibble: 1 × 1\n  AcidVolmean\n        &lt;dbl&gt;\n1       0.351\n\n\nSi on veut maintenant la teneur moyenne en acide volatile sur tous les vins regroupés par qualité :\n\nWine.tbl %&gt;% group_by(Qualite)%&gt;%summarise(AcidVolmean = mean(AcidVol,na.rm=T))\n\n# A tibble: 3 × 2\n  Qualite AcidVolmean\n  &lt;chr&gt;         &lt;dbl&gt;\n1 bad           0.423\n2 good          0.303\n3 medium        0.360\n\n\nOn veut également calculer la teneur en acide volatile minimale et maximale dans chaque groupe :\n\nWine.tbl %&gt;% group_by(Qualite)%&gt;%summarise(AcidVolmean = mean(AcidVol,na.rm=T),\n                                         AcidVolmin=min(AcidVol,na.rm=T),\n                                         AcidVolmax=max(AcidVol,na.rm=T))\n\n# A tibble: 3 × 4\n  Qualite AcidVolmean AcidVolmin AcidVolmax\n  &lt;chr&gt;         &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;\n1 bad           0.423       0.16      0.63 \n2 good          0.303       0.1       0.915\n3 medium        0.360       0.12      1.04 \n\n\nsummarise() possède un opérateur n() pour connaître le nombre de lignes par groupe :\n\nWine.tbl %&gt;%\n  group_by(Qualite) %&gt;%\n  summarise(nb = n())\n\n# A tibble: 3 × 2\n  Qualite    nb\n  &lt;chr&gt;   &lt;int&gt;\n1 bad        19\n2 good      110\n3 medium    471\n\n\nn() peut aussi être utilisé avec filter() et mutate(). On peut aussi directement utiliser la fonction count()\n\nWine.tbl %&gt;%count(Qualite) \n\n# A tibble: 3 × 2\n  Qualite     n\n  &lt;chr&gt;   &lt;int&gt;\n1 bad        19\n2 good      110\n3 medium    471\n\n\n\n\nmutate() permet de créer de nouvelles variables (colonnes) dans le tableau en conservant toutes les autres variables existantes. Par exemple, si on convertit la densité, qui est donnée en g/cm3, en mg/cm3 :\n\nWine.tbl = mutate(Wine.tbl, densmg = 1000 * Densite)\nselect(Wine.tbl,Densite,densmg)\n\n# A tibble: 600 × 2\n   Densite densmg\n     &lt;dbl&gt;  &lt;dbl&gt;\n 1   0.993   993.\n 2   0.994   994.\n 3   0.999   999.\n 4   0.998   998.\n 5   0.995   995.\n 6   0.998   998.\n 7   0.994   994.\n 8   0.992   992 \n 9   0.994   994.\n10   0.996   996.\n# ℹ 590 more rows\n\n\nLa fonction transmute() permet également d’ajouter une variable mais en supprimant les autres cette fois.\n\n\n\n\n\n4.1.4 Manipulation de chaines de caractère avec stringr \nstringr est une extension pour la manipulation de chaînes de caractères. On présente ici les fonctions les plus utilisées, qui seront illustrées sur l’exemple suivant :\n\nExChaine &lt;- tibble(\n  nom = c(\"M. Gérard MARTIN\", \"Mme Marie DUPONT\", \"M. Rémi THOMAS\"),\n  adresse = c(\"30 avenue de la République\", \"40 rue de la Libération\", \"2 impasse des pivoines\"),\n  ville = c(\"Toulouse\", \"Marseille\", \"Bordeaux\") \n)\nExChaine\n\n# A tibble: 3 × 3\n  nom              adresse                    ville    \n  &lt;chr&gt;            &lt;chr&gt;                      &lt;chr&gt;    \n1 M. Gérard MARTIN 30 avenue de la République Toulouse \n2 Mme Marie DUPONT 40 rue de la Libération    Marseille\n3 M. Rémi THOMAS   2 impasse des pivoines     Bordeaux \n\n\nPour plus de détails vous pouvez vous référer au chapitre 14 du livre de Wickham, H. et G. Grolemund (2016) dédié à la librairie stringr ainsi qu’au site web officiel de stringr.\n\nstr_length()str_c()str_to_lower() / str_to_upper') / str_to_title()str_sub() / str_extract()str_detect()str_split()str_replace()\n\n\nLa fonction str_length() permet d’obtenir la longueur d’une chaîne / tableau de caractères :\n\nstr_length(ExChaine)\n\nWarning in stri_length(string): argument is not an atomic vector; coercing\n\n\n[1] 59 84 38\n\n\n\n\nLa fonction str_c() est la fonction de stringr dédiée à la concaténation des chaines de caractères. On a déjà vu la fonction paste()de R. Voici quelques exemples :\n\nstr_c(ExChaine$nom,ExChaine$ville,sep=\" \")\n\n[1] \"M. Gérard MARTIN Toulouse\"  \"Mme Marie DUPONT Marseille\"\n[3] \"M. Rémi THOMAS Bordeaux\"   \n\n\n\nstr_c(ExChaine$nom,ExChaine$ville,sep=\"/-/\")\n\n[1] \"M. Gérard MARTIN/-/Toulouse\"  \"Mme Marie DUPONT/-/Marseille\"\n[3] \"M. Rémi THOMAS/-/Bordeaux\"   \n\n\n\nstr_c(ExChaine$nom,c(\" \",\"/---/\",\"!!!\"),ExChaine$ville)\n\n[1] \"M. Gérard MARTIN Toulouse\"      \"Mme Marie DUPONT/---/Marseille\"\n[3] \"M. Rémi THOMAS!!!Bordeaux\"     \n\n\n\n\nLes fonctions str_to_lower(), str_to_upper() et str_to_title() permettent de mettre en minuscules, en majuscules, ou en lettres capitales respectivement les éléments d’une chaînes de caractères\n\nstr_to_lower(ExChaine$nom)\n\n[1] \"m. gérard martin\" \"mme marie dupont\" \"m. rémi thomas\"  \n\nstr_to_upper(ExChaine$nom)\n\n[1] \"M. GÉRARD MARTIN\" \"MME MARIE DUPONT\" \"M. RÉMI THOMAS\"  \n\nstr_to_title(ExChaine$nom)\n\n[1] \"M. Gérard Martin\" \"Mme Marie Dupont\" \"M. Rémi Thomas\"  \n\n\n\n\nLa fonction str_sub() permet d’extraire des sous-chaînes de caractères en indiquant les positions des premier et dernier caractères :\n\nstr_sub(ExChaine$nom,3,9)\n\n[1] \" Gérard\" \"e Marie\" \" Rémi T\"\n\nstr_sub(ExChaine$nom,3)\n\n[1] \" Gérard MARTIN\" \"e Marie DUPONT\" \" Rémi THOMAS\"  \n\n\nLa fonction str_extract() permet d’extraire les valeurs correspondant à un motif.\n\nstr_extract(ExChaine,\"pivoines\")\n\nWarning in stri_extract_first_regex(string, pattern, opts_regex =\nopts(pattern)): argument is not an atomic vector; coercing\n\n\n[1] NA         \"pivoines\" NA        \n\n\nPlus subtil, cette commande permet de récupérer tous les numéros des adresses :\n\nstr_extract(ExChaine$adresse, \"^\\\\d+\")\n\n[1] \"30\" \"40\" \"2\" \n\n\nPour aller plus loin, vous pouvez consulter les références donner pour la librairie stringr.\n\n\nLa fonction str_detect() permet de détecter la présence d’un motif parmi les élements d’un vecteur de caractères. Elle renvoie un vecteur de booléens.\n\nstr_detect(ExChaine$nom,\"o\")\n\n[1] FALSE FALSE FALSE\n\nstr_detect(ExChaine$nom,\"r\")\n\n[1]  TRUE  TRUE FALSE\n\nstr_detect(str_to_lower(ExChaine$nom),\"r\")\n\n[1] TRUE TRUE TRUE\n\n\nLa fonction str_count() dénombre les occurences d’un motif dans un vecteur de caractères.\n\nstr_count(ExChaine$nom,\"r\")\n\n[1] 2 1 0\n\nstr_count(str_to_lower(ExChaine$nom),\"r\")\n\n[1] 3 1 1\n\n\n\n\nLa fonction str_split() permet de découper une chaîne de caractère (premier argument) en fonction d’un délimiteur (second argument).\n\nstr_split(ExChaine,\" \")\n\nWarning in stri_split_regex(string, pattern, n = n, simplify = simplify, :\nargument is not an atomic vector; coercing\n\n\n[[1]]\n[1] \"c(\\\"M.\"    \"Gérard\"    \"MARTIN\\\",\" \"\\\"Mme\"     \"Marie\"     \"DUPONT\\\",\"\n[7] \"\\\"M.\"      \"Rémi\"      \"THOMAS\\\")\"\n\n[[2]]\n [1] \"c(\\\"30\"        \"avenue\"        \"de\"            \"la\"           \n [5] \"République\\\",\" \"\\\"40\"          \"rue\"           \"de\"           \n [9] \"la\"            \"Libération\\\",\" \"\\\"2\"           \"impasse\"      \n[13] \"des\"           \"pivoines\\\")\"  \n\n[[3]]\n[1] \"c(\\\"Toulouse\\\",\" \"\\\"Marseille\\\",\"  \"\\\"Bordeaux\\\")\"  \n\nstr_split(ExChaine$nom,\" \")\n\n[[1]]\n[1] \"M.\"     \"Gérard\" \"MARTIN\"\n\n[[2]]\n[1] \"Mme\"    \"Marie\"  \"DUPONT\"\n\n[[3]]\n[1] \"M.\"     \"Rémi\"   \"THOMAS\"\n\nstr_split(ExChaine$nom,\"r\")\n\n[[1]]\n[1] \"M. Gé\"    \"a\"        \"d MARTIN\"\n\n[[2]]\n[1] \"Mme Ma\"    \"ie DUPONT\"\n\n[[3]]\n[1] \"M. Rémi THOMAS\"\n\n\nOn peut également l’appliquer sur un tableau en ajoutant l’option simplify = TRUE.\n\n\nLa fonction str_replace() permet de remplacer une chaîne ou un motif par une autre.\n\nstr_replace(ExChaine$nom,\"Mr\",\"M.\")\n\n[1] \"M. Gérard MARTIN\" \"Mme Marie DUPONT\" \"M. Rémi THOMAS\"  \n\n\nPour spécifier plusieurs remplacements d’un coup, on peut utiliser str_replace_all()\n\nstr_replace_all(ExChaine$adresse,c(\"avenue\"=\"Av.\",\"rue\"=\"Rue\",\"impasse\"=\"Imp.\"))\n\n[1] \"30 Av. de la République\" \"40 Rue de la Libération\"\n[3] \"2 Imp. des pivoines\"    \n\n\n\n\n\n\n\n4.1.5 Visualisation avec ggplot2 \nggplot2 est une extension dédiée aux graphiques. Elle est basée sur une syntaxe particulière (il faut oublier les graphiques de base de R) mais robuste et efficace pour la construction de graphiques complexes. Elle demande donc un peu d’investissement pour se familiariser avec la syntaxe. Elle part du principe (comme tout package de tidyverse) que les données relatives au graphique sont stockées dans un tableau (data.frame ou tibble). Pour plus de détails, on peut consulter le livre “Ggplot2: Elegant Graphics for Data Analysis” de Wickham (2016) et le site web de ggplot2.\nUn graphique en ggplot2 s’initialise avec la fonciton ggplot() qui prend en argument le jeu de données étudié. Par exemple, pour le jeu de données Wine,\n\ngEx = ggplot(data=Wine)\n\nPour l’instant, on ne voit rien mais pourtant l’objet gEx contient des informations :\n\nsummary(gEx)\n\ndata: Qualite, Type, AcidVol, AcidCitr, SO2lbr, SO2tot, Densite, Alcool\n  [600x8]\nfaceting: &lt;ggproto object: Class FacetNull, Facet, gg&gt;\n    compute_layout: function\n    draw_back: function\n    draw_front: function\n    draw_labels: function\n    draw_panels: function\n    finish_data: function\n    init_scales: function\n    map_data: function\n    params: list\n    setup_data: function\n    setup_params: function\n    shrink: TRUE\n    train_scales: function\n    vars: function\n    super:  &lt;ggproto object: Class FacetNull, Facet, gg&gt;\n\nnames(gEx)\n\n [1] \"data\"        \"layers\"      \"scales\"      \"guides\"      \"mapping\"    \n [6] \"theme\"       \"coordinates\" \"facet\"       \"plot_env\"    \"layout\"     \n[11] \"labels\"     \n\ngEx$layers\n\nlist()\n\n\nmais pour l’instant son layers est vide.\nOn ajoute ensuite des éléments graphiques, appelés geom, à l’objet graphique grâce à l’opérateur + et on précise à l’aide de la fonction aes() les données à utiliser en argument du geom. Par exemple, si on veut faire l’histogramme de la variable Alcool\n\nggplot(data=Wine)+\n   geom_histogram(aes(x=Alcool))\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\nOn peut également ajouter un mappage, c’est à dire une mise en relation entre un attribut graphique d’un geom et une variable du tableau de données. Par exemple, on peut mettre des couleurs à un nuage de points en fonction d’une variable qualitative, … Il faut bien distinguer un mappage d’une modification d’un attribut graphique sans lien avec une variable. Une règle importante à retenir est donc\n\npour définir un mappage (relation entre les valeurs d’une variable et un attribut graphique), on le déclare dans aes()\npour modifier un attribut graphique de la même manière pour tous les points, on le définit en-dehors de la fonction aes().\n\nDans la présentation qui suit des geom usuels, on proposera quelques illustrations de mappages. Chaque geom a sa liste de mappages possibles.\n\n4.1.5.1 Les geom usuels\nNous allons ici présenter les geom les plus connus.\n\ngeom_histogram()geom_point()geom_boxplot()geom_violin()geom_bar()geom_density()geom_line()\n\n\ngeom_histogram() permet de représenter l’histogramme d’une variable quantitative.\n\nggplot(data=Wine)+\n  geom_histogram(aes(x=Alcool))\n\n\n\n\n\nggplot(data=Wine)+\n  geom_histogram(aes(x=Alcool),binwidth=0.2,color=\"red\",fill=\"white\")\n\n\n\n\n\nggplot(data=Wine)+\n  geom_histogram(aes(x=Alcool,fill=Qualite),binwidth=0.2)\n\n\n\n\n\n\ngeom_point() permet de représenter un nuage de points. Il faut préciser la position en x (la variable sur l’axe horizontal) et en y (la variable sur l’axe vertical) de ces points dans aes().\n\nggplot(data=Wine) +\n  geom_point(aes(x=Alcool,y=Densite))\n\n\n\n\nOn peut modifier certains attributs de ce graphique comme la couleur des points (color), la taille des points (size), leur transparence (alpha).\n\nggplot(data=Wine) +\n  geom_point(aes(x=Alcool,y=Densite),color=\"darkblue\",size=3,alpha=0.4)\n\n\n\n\n\nggplot(data=Wine) +\n  geom_point(aes(x=Alcool,y=Densite,color=Qualite,size=AcidVol),alpha=0.6)\n\n\n\n\n\n\ngeom_boxplot() permet de représenter des boxplot (boites à moustaches). On lui précise en y la variable quantitative dont on veut étudier la répartition, et en x la variable qualitative contenant les groupes à comparer.\n\nggplot(data=Wine)+\n  geom_boxplot(aes(x=Qualite,y=Alcool))\n\n\n\n\nVous pouvez vous référer à l’aide et la documentation en ligne pour ensuite améliorer ce graphique en modifiant certaines options.\n\nggplot(data=Wine)+\n  geom_boxplot(aes(x=Qualite,y=Alcool))+\n  coord_flip()\n\n\n\n\n\nggplot(data = Wine) +\n  geom_boxplot(aes(x=Qualite,y=Alcool),outlier.colour=\"darkgreen\", outlier.shape=25,\n             outlier.size=3, varwidth = T,fill=\"red\",color=\"blue\")\n\n\n\n\n\n\ngeom_violin() est très proche de la représentation boxplot mais utilise la représentation en violon plutôt que la boite à moustaches, ce qui permet de mieux visualiser la distribution des données.\n\nggplot(data=Wine)+\n  geom_violin(aes(x=Qualite,y=Alcool))\n\n\n\n\n\nggplot(data =Wine) +\n  geom_violin(aes(x=Qualite,y=Alcool), fill=\"red\",color=\"blue\")\n\n\n\n\n\n\ngeom_bar() permet la représentation en batôns (barplot) d’une variable qualitative (précisée en argument x à aes()).\n\nggplot(data=Wine) +\n  geom_bar(aes(x=Qualite))\n\n\n\n\nOn peut modifier le visuel en changeant certaines options. Par exemple,\n\nggplot(data=Wine) + \n  geom_bar(aes(x=Qualite),fill = \"darkblue\", width = .5)\n\n\n\n\n\nggplot(data=Wine) + \n  geom_bar(aes(x=Qualite,y = ..prop..,group=1),fill = \"darkblue\", width = .5)\n\n\n\n\nOn peut aussi obtenir la représentation en camembert en modifiant un peu le graphique en baton en passant en “coordonnées polaires”\n\nggplot(Wine, aes(x = \" \", fill = Qualite))+\n  geom_bar(width = 1)+ \n  coord_polar(theta = \"y\")\n\n\n\n\n\n\ngeom_density() permet de représenter l’estimation de la densité d’une variable quantitative. Son utilisation est similaire à geom_histogram().\n\nggplot(data=Wine) + \n  geom_density(aes(x=Alcool))\n\n\n\n\n\nggplot(data=Wine) + \n  geom_density(aes(x=Alcool,fill=Qualite),alpha=0.3)\n\n\n\n\n\n\ngeom_line() permet de tracer des lignes pour connecter des points entre eux. C’est en particulier utiliser pour représenter des séries temporelles.\n\ndata(\"economics\")\nggplot(data=economics) +\n  geom_line(aes(x = date, y = unemploy))\n\n\n\n\n\n\n\n\n\n4.1.5.2 Pour aller plus loin\n\nReprésentations de plusieurs geomFacetingLes scalesThèmesPackages complémentaires et documentations\n\n\nOn peut représenter plusieurs geom sur un même graphique simultanément, il suffit d’utiliser l’opérateur + pour les ajouter au fur et à mesure. On donne ici quelques exemples pour illustrer.\n\nggplot(data=Wine)+\n  geom_violin(aes(x=Qualite,y=Alcool))+\n   geom_point(aes(x=Qualite,y=Alcool), col = \"blue\", alpha = 0.2,position=\"jitter\")\n\n\n\n\n\nggplot(data=Wine,aes(x=Alcool,y=Densite))+\n  geom_point()+\n  geom_smooth(method=\"lm\")\n\n\n\n\n\n\nfaceting est le terme pour faire un même graphique plusieurs fois selon les modalités d’une ou des variable(s) qualitative(s). On peut utiliser les fonctions facet_wrap() et facet_grid() qui prennent une variable qualitative sous la forme d’une formule ~variable. Les différents graphiques sont affichés les uns à côtés des autres avec facet_wrap() et selon une grille avec facet_grid() (prend une formule variable ligne ~ variable colonne).\n\nggplot(data=Wine) +\n  geom_point(aes(x=Alcool,y=Densite))+\n  facet_wrap(~Qualite)\n\n\n\n\n\nggplot(data=Wine) +\n  geom_point(aes(x=Alcool,y=Densite))+\n  facet_grid(Qualite~.)\n\n\n\n\n\nggplot(data=Wine) +\n  geom_point(aes(x=Alcool,y=Densite))+\n  facet_grid(Qualite~Type)\n\n\n\n\n\n\nLes scales permettent de modifier la façon dont un attribut graphique est lié aux valeurs d’une variable. Pour les modifier, on ajoute un nouvel élément de la forme scale_&lt;attribut&gt;_&lt;type&gt; à l’objet graphique ggplot2 avec +. Les fonctions scale les plus connues sont :\n\nscale_size() (avec son argument range) pour modifier les tailles minimales, maximales, …\nscale_x() et scale_y() pour modifier l’axe xet l’axe y respectivement\nscale_x_continuous() (resp. scale_x_discrete()) pour modifier l’axe des x dans le cas d’une variable quantitative (resp. une variable qualitative)\nscale_y_continuous() (resp. scale_y_discrete()) pour modifier l’axe des y dans le cas d’une variable quantitative (resp. une variable qualitative)\nscale_color() pour modifier les couleurs de dessin\nscale_fill() pour modifier les couleurs de remplissage\n\nPour les couleurs, on peut spécifier un gradient de couleur sur une variable quantitative avec scale_color_gradient(), modifier manuellement la palette de couleur avec scale_color_manual(), faire appel à une palette de couleur prédéfinie (par exemple en utilisant le package viridis avec scale_color_viridis, en s’appuyant sur les palettes disponibles dans ColorBrewer avec scale_color_brewer()), … \n\nggplot(data=Wine)+\n  geom_point(aes(x=Alcool,y=Densite,size=AcidVol))+\n  scale_size(\"Acide vol.\", range = c(0,1.5),breaks=seq(0,1.5,0.2)) +\n  scale_x_continuous(\"Alcool\",limits=c(8,16)) +\n  scale_y_continuous(\"Densité\",limits=c(0.985,1.01))\n\n\n\n\n\nggplot(Wine) + \n  geom_bar(aes(x = Qualite)) +\n  scale_x_discrete(\"Qualité du vin\")\n\n\n\n\n\n\nLes thèmes permettent de gérer l’affichage des éléments graphiques non liés aux données comme les titres, les fonds, les grilles, … Il existe plusieurs thèmes prédéfinis comme theme_classic(), theme_minimal() et theme_bw(). On a aussi le package ggthemes qui fournit d’autres thèmes par exemple.\n\ng=ggplot(data=Wine)+\n  geom_point(aes(x=Alcool,y=Densite)) \ng1=g+theme_classic()\ng2=g+theme_minimal()\ng3=g+theme_bw()\ngrid.arrange(g1,g2,g3,ncol=3)\n\n\n\n\nOn peut modifier chaque élément séparément avec une commande spécifique, par exemple :\n\nggtitle() pour modifier le titre\nxlab()et ylab() pour modifier l’intituler de l’axe des abscisses et des ordonnées respectivement\n\nAvec la fonction theme(), on peut contrôler les éléments graphiques incluant :\n\nles éléments linéaires (element_line()): traits des axes, traits des grilles mineur et majeur, bordure du panneau graphique, graduation des axes, couleurs de fond, …\nles éléments textuels (element_text()): titre du graphique et des axes, titre et textes de la légende, les étiquettes des graduations des axes, …\nles éléments rectangulaires (element_rect()) : arrière plan du graphique, du panneau et de la légende, … Les fonctions entre parenthèses sont spécifiques pour modifier chacun de ces trois éléments.\n\nEn bref, les possibles avec ggplot2 sont infinis car de nombreux éléments sont personnalisables. Un moyen pour maitriser toutes ces possibilités est l’utilisation de l’addin RStudio ggThemeAssist. Pour cela, il faut installer le package ggThemeAssist, de sélectionner le code correspondant à un graphique ggplot2 et d’aller dans le menu Addins pour choisir ggplot Theme Assistant. Une interface graphique s’ouvre alors, permettant de modifier différents éléments du graphique et d’en récupérer le code correspondant.\n\n\nOn donne ici une liste non exhaustive de packages que l’on peut utiliser en complément de ggplot2 :\n\nLe package plotly permet d’avoir des graphiques interactifs. On peut par exemple utiliser la fonction ggplotly() sur un graphique ggplot2\nLe package gridExtra permet d’organiser plusieurs graphiques sur une même fenêtre graphique. On peut par exemple utiliser la fonction grid.arrange().\n\nLe package cowplot contient des fonctionnalités qui permettent d’avoir des graphiques de qualité pour des publications, en particulier pour l’organisation de plusieurs graphiques.\nLe package esquisse est un package qui fournit une interface graphique pour la construction de graphiques avec ggplot2.\n\n\nlibrary(plotly)\ng=ggplot(Wine,aes(x=Alcool,y=Densite))+\n  geom_point()+\n  geom_smooth()\nggplotly(g)\n\n\n\n\n\nNous donnons ici quelques références pour les graphiques en ggplot2 mais il existe de nombreuses ressources sur le web :\n\nLe livre Ggplot2: Elegant Graphics for Data Analysis de H. Wickham. (Wickham 2016)\nLe site web de ggplot2\nThe R Graph Gallery\nThe Cheat Sheet de ggplot 2"
  },
  {
    "objectID": "Part4-Ravance.html#le-package-rmarkdown",
    "href": "Part4-Ravance.html#le-package-rmarkdown",
    "title": "4  Pour aller plus loin avec R et RStudio",
    "section": "4.2 Le package rmarkdown ",
    "text": "4.2 Le package rmarkdown \nL’extension Rmarkdown permet de créer des documents dans différents formats (html, pdf, docx, slides, …) qui contiennent du texte, du code (en R mais pas que!), les résultats, … L’utilisation de Rmarkdown permet d’obtenir un document final reproductible, associant code, résultats et commentaires. Le document peut être facilement regénéré et mis à jour (par exemple si les données étudiées ont été modifiées).\nNous allons donner ici des éléments de base pour la création de documents avec Rmarkdown. Pour plus de détails, vous pouvez consulter par exemple le livre en ligne R Markdown: The Definitive Guide de Y. Xie, J. J. Allaire, G. Grolemund. (2018)\n\n4.2.1 Etapes de création d’un document\nUn document Rmarkdown est un fichier enregistré avec l’extension .Rmd. Pour créer un nouveau document, allez dans File-&gt; NewFile-&gt; Rmarkdown... (ou cliquez sur l’icone nouveau document et choisissez Rmarkdown). La boîte de dialogue suivante s’ouvre :\n\n\n\n\n\nBoite de dialogue Rmarkdown\n\n\n\n\nVous pouvez choisir le format du fichier final souhaité, préciser le titre et l’auteur (qui peuvent être modifiés ensuite si besoin). On peut remarquer que l’on peut aussi faire des présentations avec Rmarkdown et on peut utiliser des templates existants.\nExercice :\n\nCréez un nouveau document Rmarkdown au format html avec le titre et l’auteur de votre choix. Vous pouvez constater qu’un nouveau document prérempli vient de s’ouvrir dans RStudio. Nous allons maintenant détailler le contenu de ce document.\n\nUn document Rmarkdown débute toujours par l’en-tête qui est encadré par 3 tirets ---. Cet en-tête contient les métadonnées du document : le titre, l’auteur, la date, le format de sortie (output). Quelques éléments seront précisés dans la section Contenu de l’en-tête.\nOn a ensuite le corps du document qui peut contenir\n\ndu texte selon la syntaxe markdown (voir la section Quelques éléments markdown)\ndes blocs de code (appelés chunks) en R, Python, … (voir la section Options des blocs de code)\ndes formules mathématiques (écrites en latex entre $ ... $)\ndes images, tableaux, références, ….\n\nVous pouvez compiler à tout moment le document Rmarkdown en cliquant sur le bouton  et de choisir le format de sortie voulu. Un onglet R Markdown s’ouvre alors dans la même zone que l’onglet Console pour indiquer la progression de la compilation et les messages d’erreur éventuels. Une fois la compilation effectuée, le document obtenu s’ouvre et vous pouvez admirer le rendu. Vous pouvez personnaliser le document de sortie en cliquant sur l’icone  et en choisissant Output Options....\nRemarque:\n\nPour la compilation d’un document en pdf, il est nécessaire d’avoir installé un compilateur de Latex sur son ordinateur. Si ce n’est pas le cas, vous pouvez utiliser l’extension tinytex (voir ici pour plus de détails) \n\n\ninstall.packages(\"tinytex\")\ntinytex::install.tinytex()\n\n\n\n4.2.2 Contenu de l’en-tête\nUn document Rmarkdown débute par un en-tête entre --- au format YAML contenant les métadonnées du document. Voici un exemple de base de préambule :\n---\ntitle: \"Titre\"\nauthor: \"Prénom Nom\"\ndate: \"31 aout 2020\"\noutput: html_document\n---\nIci output: html_document indique le document final généré sera au format html. On peut modifier cette option par pdf_documentpour un document pdf, word_document pour docx, et bien d’autres possibilités.\nEn executant la fonction Sys.Date() pour l’option date, la date sera remise à jour automatiquement à chaque compilation du document.\nOn peut préciser des options au document final en ajoutant des sous-options à droite du output. Il est également possible de spécifier des options différentes selon les formats. Voici un exemple :\n---\ntitle: \"Titre\"\nauthor: \"Prénom Nom\"\ndate: \"`r Sys.Date()`\"\noutput: \n  html_document :\n    toc : TRUE\n    toc_float : TRUE\n    number_sections : TRUE\n    fig_width : 4\n  pdf_document : \n    fig_caption: TRUE\n    highlight: kate\n---\nVoici une liste avec quelques éléments :\n\nnumber_section : true permet de numéroter les sections\nhighlight permet de spécifier le style syntaxique (par ex default, tango, pygments, kate, …).\non peut ajouter son propre fichier de style .css avec l’option css\non peut préciser des options concernant les figures avec fig_width, fig_height, fig_caption, dev, …\non peut ajouter une bibliographie à partir d’un fichier .bib avec l’option bibliography\n\nSi vous utilisez la boite de dialogue des options du document de sortie Output Options ..., l’en-tête sera remis à jour pour suivre les options choisies.\nPour plus de détails voir le site détaillant les R Markdown formats et l’aide mémoire de Rmarkdown (accessible via Help -&gt; Cheatsheets -&gt; Rmarkdown Cheat Sheet).\nExercice :\n\nCréez un nouveau fichier Rmarkdown et enregistrez-le. Modifiez les options dans l’en-tête et compilez le document pour constater l’impact sur le document généré\n\n\n\n4.2.3 Quelques éléments markdown\nLe texte d’un document Rmarkdown est régi par le langage markdown. Voici quelques éléments de syntaxe et de mise en forme\n\n\n\nFigure 4.1: Extrait du Cheat Sheet de Rmarkdown\n\n\nRemarque: Si vous avez organisé votre document avec des sections / sous-sections en faisant débuter une ligne par un ou plusieurs #, alors vous pouvez cliquer sur l’icone  à droite de la barre d’outils associée au fichier R Markdown pour visualiser la table des matières générée automatiquement qui vous permet de naviguer facilement dans le document.\nPour plus de détails, on peut aller voir\n\nsous RStudio, allez dans Help -&gt; Markdown Quick Reference : une fenêtre d’aide en bas à droite s’ouvre donnant les bases de syntaxe markdown\nsous RStudio, allez dans Help -&gt; Cheatsheets -&gt; R Markdown Cheat Sheet qui permet d’aller consulter le document suivant.\nConsulter la page web du markdown guide\n\n\n\n4.2.4 Options des blocs de code (chunks)\nPour insérer du code dans un document Rmarkdown, on utilise des blocs appelés chunk. Pour cela, il suffit de cliquer sur l’icone d’insertion d’un chunk  dans la barre d’outils d’un document Rmarkdown. Il est possible d’insérer un chunk de code R mais pas seulement (par exemple on peut insérer du code Python). Pour du code R, un chunk de cette forme s’insère alors dans le document\n```{r}\n\n```\nOn peut alors saisir du code R dans ce chunk. On peut ajouter un nom à un bloc juste après r ({r nomdubloc}). On peut également préciser des options dans les accolades {r nomdubloc, ....}, par exemple\n\n\n\n\n\nQuelques options des blocs de code (chunk)\n\n\n\n\n\nCes options peuvent être modifiées manuellement ou en utilisant l’interface graphique (en cliquant sur l’icone d’engrenage situé en haut à droite de chaque bloc).\nLorsque l’on veut appliquer une (des) option(s) à l’ensemble des blocs du document, on utilise la fonction knitr::opts_chunk$set() dans un bloc spécial appelé setup et qui est le premier bloc du document:\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = TRUE)\n```"
  },
  {
    "objectID": "Part4-Ravance.html#rédaction-avec-quarto",
    "href": "Part4-Ravance.html#rédaction-avec-quarto",
    "title": "4  Pour aller plus loin avec R et RStudio",
    "section": "4.3 Rédaction avec Quarto ",
    "text": "4.3 Rédaction avec Quarto \n\nQuarto est la nouvelle génération de Rmarkdown. Les documents Quarto ressemblent beaucoup aux documents Rmarkdown. Il y a un en-tête YAML, des morceaux de textes et de code, un formatage avec des balises markdown, … Mais Quarto permet une interface en ligne de commande, la possibilité d’utiliser de nombreux langages (y compris Python, bash, Julia, etc.), et l’ouverture vers d’autres fonctionnalités qui n’étaient pas possibles dans RMarkdown. Quarto n’est pas un package R, c’est un logiciel qui peut s’utiliser avec RStudio, Jupyter, …. Il s’installe automatiquement lors de l’installation de RStudio.\nComme Rmarkdown, il permet de créer des documents dans différents formats (html, pdf, docx, slides, …) qui contiennent du texte, du code (en R, en python, …), les résultats, … L’utilisation de Quarto permet d’obtenir un document final reproductible, associant code, résultats et commentaires. Le document peut être facilement regénéré et mis à jour.\nNous allons donner ici des éléments de base pour la création de documents avec Quarto. Pour plus de détails, vous pouvez consulter le guide en ligne de Quarto.\n\n4.3.1 Etapes de création d’un document\nUn document Quarto est un fichier enregistré avec l’extension .qmd. Pour créer un nouveau document, allez dans File-&gt; NewFile-&gt; Quarto Document ... (ou cliquez sur l’icone nouveau document et choisissez Quarto Document…). La boîte de dialogue suivante s’ouvre :\n\n\n\n\n\nVous pouvez choisir le format du fichier final souhaité, préciser le titre et l’auteur (qui peuvent être modifiés ensuite si besoin). On peut remarquer que l’on peut aussi faire des présentations avec Quarto et on peut utiliser des templates existants (voir exemples).\nExercice :\n\nCréez un nouveau document Quarto au format html avec le titre et l’auteur de votre choix. Vous pouvez constater qu’un nouveau document vient de s’ouvrir dans RStudio avec un en-tête YAML.\n\nUn document Quarto débute toujours par l’en-tête qui est encadré par 3 tirets ---. Cet en-tête contient les métadonnées du document : le titre, l’auteur, la date, le format de sortie (format). Quelques éléments seront précisés dans la section Contenu de l’en-tête.\nOn a ensuite le corps du document qui peut contenir\n\ndu texte selon la syntaxe markdown (voir la section Quelques éléments markdown) comme en Rmarkdown.\ndes blocs de code (appelés chunks) en R, Python, … (voir la section Options des blocs de code)\ndes formules mathématiques (écrites en latex entre $ ... $)\ndes images, tableaux, références, ….\n\nVous pouvez compiler à tout moment le document Quarto en cliquant sur le bouton . La progression de la compilation s’affiche alors dans l’onglet Background Jobs dans la même zone que l’onglet Console. Une fois la compilation effectuée, le document obtenu s’ouvre et vous pouvez admirer le rendu.\nRemarque: Pour la compilation d’un document en pdf, il est nécessaire d’avoir installé un compilateur de Latex sur son ordinateur.\n\n\n4.3.2 Contenu de l’en-tête\nUn document Quarto débute par un en-tête entre --- au format YAML contenant les métadonnées du document. Il y a quelques différences avec l’en-tête d’un document Rmarkdown. Attention, il faut bien respecter l’indentation.\n\n\nAvec Quarto\n---\ntitle: \"Titre\"\nauthor: \"Prénom Nom\"\ndate: \"31 aout 2020\"\nformat: \n  html:\n    toc: TRUE\n    number_sections: TRUE\n---\n\n\n\nAvec Rmarkdown\n---\ntitle: \"Titre\"\nauthor: \"Prénom Nom\"\ndate: \"31 aout 2020\"\noutput: \n  html_document:\n    toc: TRUE\n    number_sections: TRUE\n---\n\n\nOn peut préciser des options au document final en ajoutant des sous-options à droite du format. Il est également possible de spécifier des options différentes selon les formats.\nOn peut par exemple jouer sur les sections et la table des matière avec\n\nnumber_section : true permet de numéroter les sections\nnumber_depth: 3 pour adapter la profondeur de numérotation\ntoc: true pour avoir une table des matières\ntoc-depth: 2 pour gérer la profondeur de la table des matières\ntoc-title: Contents pour modifier le titre de la table des matières\n\nOn peut ajouter une bibliographie à partir d’un fichier .bib avec l’option bibliography, utiliser un style via un fichier .cssou .scss avec l’option css, …. Pour plus de détails voir le guide de Quarto et l’aide mémoire de Quarto (Cheatsheets).\nExercice :\n\nOuvrez le fichier Data/ExempleQuarto.qmd. Modifiez les options dans l’en-tête et compilez-le pour constater l’impact sur le document généré.\n\n\n\n4.3.3 Contenu du document\n\nTexte par markdown\nLe texte d’un document Quarto est régi par le langage markdown. Ce sont les mêmes éléments de syntaxes qu’en Rmarkdown, voici la figure Figure 4.1 et la section Section 4.2.3.\n\n\nInsertion de code\nPour insérer du code dans un document Quarto, on utilise aussi des blocs appelés chunk. Pour cela, il suffit de cliquer sur l’icone d’insertion d’un chunk . Il est possible d’insérer un chunk de code R mais pas seulement (par exemple on peut insérer du code Python). On peut alors saisir du code R dans ce chunk. On peut également préciser des options avec la syntaxe #|.... en dehors de l’accolade {r} (grande différence avec Rmarkdown mais Quarto s’adapte au code du Rmarkdown). Voici quelques options d’execution :\n\n\n\n\n\noption\neffet\n\n\n\n\necho\ninclude le code ou pas\n\n\neval\nevalue le code ou pas\n\n\nwarning\naffiche les warnings ou pas\n\n\nmessage\naffiche les messages ou pas\n\n\nerror\ninclude les erreurs et poursuit ou pas\n\n\n\n\n\n```{r}\n#| echo: true\n#| warning: false\n\n```\nPour appliquer une option sur tous les chunk du document, il faut le préciser dans l’en-tête dans la partie execute\n---\ntitle: \"Titre\"\nauthor: \"Prénom Nom\"\ndate: \"31 aout 2020\"\nformat: \n  html:\n    toc: TRUE\n    number_sections: TRUE\nexecute: \n  echo: true\n  warning: false\n---\n\n\nInsertion d’une figure\nPour insérer une image (.png, jpeg, …), on peut utiliser la syntaxe\n![CAP]{image.png}{#fig-LABEL fig-alt=\"ALT\"}\nOn peut aussi créer une image par du code, par exemple faire un graphique avec ggplot2.\nOn peut utiliser des options pour la mise en forme dont\n\n\n\n\n\noption\neffet\n\n\n\n\nfig-align\nAlignement horizontal de la figure (left, right, center)\n\n\nfig-cap\nEnoncé de la légende\n\n\nfig-height\nHauteur de la figure\n\n\nfig-width\nLargeur de la figure\n\n\n\n\n\nPour plus de détails et de possibilités, vous pouvez consulter la page suivante.\n\n\nInsertion d’un tableau\nPour insérer un tableau, on peut le créer dans le texte avec la syntaxe markdown :\n\n\nEcriture dans le fichier .qmd\n| First Header | Second Header |\n|--------------|---------------|\n| Content Cell | Content Cell  |\n| Content Cell | Content Cell  |\n\nRendu à la compilation\n\n\nTable 4.1: CAPTION\n\n\nFirst Header\nSecond Header\n\n\n\n\nContent Cell\nContent Cell\n\n\nContent Cell\nContent Cell\n\n\n\n\n\n\nOn peut aussi utiliser la fonction knitr::kable() sur un data.frame\n``{r}\n#| label: tbl-LABEL\n#| tbl-cap: CAPTION\n\ndf&lt;-data.frame( ..... )\nknitr::kable(df)\n```\nOn peut utiliser des options pour la mise en forme dont\n\n\n\n\n\n\n\n\n\noption\neffet\n\n\n\n\ntbl-colwidths\nPour spécifier la largeur des colonnes\n\n\ntbl-cap\nPour spécifier la légende du tableau\n\n\ntbl-cap-location\nPour spécifier la position de la légende (top,bottom,margin)\n\n\n\n\n\nPour plus de détails, vous pouvez consulter la page suivante..\n\n\nCallout blocks\nUne nouveauté avec Quarto est de pouvoir mettre en avant des éléments par des blocs appelés Callout blocks.\nIl y a 5 types de blocs : tip, note, warning, caution et important.\n\nLa syntaxe pour les utiliser est la suivante :\n::: {.callout-tip}\n## Title\n\nTexte, code, ....\n:::\nOn peut modifier l’apparence avec l’option appearance=\n\n\n\n\n\n\n\n\n\noption\neffet\n\n\n\n\ndefault\napparence par défaut avec un en-tête coloré et une icône\n\n\nsimple\napparence sans arrière-plan d’en-tête coloré\n\n\nminimal\napparence avec des bordures sans couleur d’arrière-plan d’en-tête ou d’icône\n\n\n\n\n\nOn peut aussi juste supprimer l’icone avec l’option icon=false."
  },
  {
    "objectID": "Part4-Ravance.html#le-package-reticulate-pour-python",
    "href": "Part4-Ravance.html#le-package-reticulate-pour-python",
    "title": "4  Pour aller plus loin avec R et RStudio",
    "section": "4.4 Le package reticulate pour Python ",
    "text": "4.4 Le package reticulate pour Python \nIl est possible d’executer du code Python sous Rstudio, de compiler un document Rmarkdown contenant à la fois du code Python et du code R, écrire des scripts python, …\nL’interface R pour faire du Python est le package reticulate. Il fournit un ensemble d’outils pour l’inter-opérabilité entre Python et R, il comprend des fonctionnalités pour :\n\nappeler Python à partir de R de différentes manières, y compris R Markdown, importer des modules Python, utiliser Python de manière interactive dans une session R, …\nfaire l’articulation entre les objets R et Python (par exemple, entre les data.frames de R et Pandas, ou entre les matrices R et les tableaux NumPy).\nfaire la liaison à différentes versions de Python, y compris les environnements Virtual et les environnements Conda.\n\nPar défaut, reticulate utilise la version de Python indiquée dans le PATH (Sys.which(\"python\")) mais il est possible de lui spécifier une autre version de python à l’aide de la fonction use_python(\"...\"). On peut aussi utiliser `use_virtualenv(\"...\") ou use_condaenv(\"...\") pour Virtual et Conda respectivement.\nOn peut installer des packages de python avec les commandes pip ou conda.\nOn peut intégrer du python de différentes façons\n\nDes chunks Python dans un document Rmarkdown ({python} ....)\nCommunication bidirectionnelle entre R et Python (les fonctions de R peuvent accéder aux objets python et inversement) :\n\npour utiliser un objet python (objectpy) avec R, on utilise py (py$objectpy)\npour utiliser un objet R (objectR) avec python, on utilise r (r.objectR)\n\nAppel d’un module Python avec la commande import()\nAppel d’une fonction python avec la commande source_python(\"nomfonction.py\") (comme la commande source()pour R)\nPasser à une console python interactive avec la fonction repl_python() dans une session de R.\n\nDeux exemples d’échanges entre R et Python sont disponibles ci-dessous.\n\n4.4.1 Exemple 1\n```{r}\nlibrary(reticulate)\nWineR=read.table(\"../Data/wine.txt\",header=T)\nhead(WineR)\nlibrary(ggplot2)\nggplot(WineR,aes(x = Alcool, y = Densite)) + geom_point()\n```\n```{python}\nWinePy = r.WineR\nWinePy.head()\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nsns.set_style(\"darkgrid\")\nplt.figure(figsize = (20, 6))\nplt.scatter(WinePy[\"Alcool\"],WinePy[\"Densite\"])\n```\n\n\n4.4.2 Exemple 2\n```{python}\nimport numpy as np\na = {i : np.random.randn() for i in range(10)}\na\n```\n```{r}\nprint(as.data.frame(py$a))\n```\n\n\n\n\nWickham, H. et al. 2014. “Tidy Data.” Journal of Statistical Software 59 (10): 1–23.\n\n\nWickham, H. 2016. Ggplot2: Elegant Graphics for Data Analysis. springer.\n\n\nWickham, H., and G. Grolemund. 2016. R for Data Science: Import, Tidy, Transform, Visualize, and Model Data. \" O’Reilly Media, Inc.\". https://r4ds.had.co.nz/.\n\n\nXie, Y., J. J. Allaire, and G. Grolemund. 2018. R Markdown: The Definitive Guide. CRC Press."
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Cornillon, Pierre-André, François Husson, Nicolas Jégou, Eric\nMatzner-Lober, Julie Josse, Arnaud Guyader, Laurent Rouviére, and Maela\nKloareg. 2010. Statistiques Avec r. Rennes (Presses\nuniversitaires de).\n\n\nWickham, H. et al. 2014. “Tidy Data.” Journal of\nStatistical Software 59 (10): 1–23.\n\n\nWickham, H. 2016. Ggplot2: Elegant Graphics for Data Analysis.\nspringer.\n\n\nWickham, H., and G. Grolemund. 2016. R for Data Science: Import,\nTidy, Transform, Visualize, and Model Data. \" O’Reilly Media,\nInc.\". https://r4ds.had.co.nz/.\n\n\nXie, Y., J. J. Allaire, and G. Grolemund. 2018. R Markdown: The\nDefinitive Guide. CRC Press."
  }
]